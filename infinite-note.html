<!DOCTYPE html>
<html lang="">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>∞ Note</title>
    <link rel="icon" href="assets/icons/infinite-note.png">
    <link rel="shortcut icon" href="assets/icons/infinite-note.png">
    <link rel="apple-touch-icon" href="assets/icons/infinite-note.png">

    <script src="https://cdnjs.cloudflare.com/ajax/libs/zepto/1.2.0/zepto.min.js"></script> <!-- For avoiding delay of pen interaction introduced by browser -->

    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/1.5.3/jspdf.min.js"></script> <!-- For generating PDF file -->
</head>
<body>
    <style>
        body {
            touch-action: none ;
            -webkit-user-select: none;
            user-select: none;
            align-items: center;
            justify-content: center;
            margin: 0;
            padding: 0;
            background-color: white;
        }

        canvas {
            touch-action: none;
            -webkit-user-select: none;
            user-select: none;
            margin: 0;
            padding: 0;
            background-color: white;
        }

        button {
            margin-top: 10px;
            border-radius: 1.5em;
            box-shadow: 0.1em 0.3em 1.5em 0.0em #00000094;
            z-index: 2;
        }

        .submenu {
            display: none;
            position: absolute;
            margin: 0;
            padding-left: 1em;
            padding-right: 1em;
            padding-top: 0;
            padding-bottom: 0;
            list-style-type: none;
            background-color: white;
            box-shadow:0.1em 0.3em 1.5em 0.0em #000000bd;
            border-radius: 0.5em;
            border-top-left-radius: 0;
            z-index: 3;
        }

        .submenu li {
            line-height: 3em;
            border-bottom: 1px solid #ccc;
        }

        .submenu li:last-child {
            border-bottom: none; /* Remove the border from the last list item */
        }
    </style>

    <canvas id="drawingCanvas" style="position: absolute; width: 100%; height: 100%; z-index: 1;"></canvas>

    <p id="state" style="z-index: 2; position: absolute; left: 1em; bottom: 0em; color: red; opacity: 1;"></p>
    
    <button id="fileButton" style="position: absolute; height: 3em; left: 1em; top: 1em; border: none;">
        <img src="assets\infinite-note\document.svg" alt="Document" style="height: 2.5em;"></svg>
        ▼
    </button>
    <ul class="submenu" id="fileMenu">
        <li id="deleteDocument">Delete document</li>
        <li id="renameDocument">Rename document</li>
        <li id="shareJSON">Share JSON</li>
        <li id="sharePDF">Share PDF</li>
        <li id="fromJSON">Reconstruct with JSON from clipboard</li>
        <li id="toJSON">Convert to JSON to clipboard</li>
    </ul>

    <button id="penButton" style="position: absolute; width: 3em; height: 3em; left: 15em; top: 1em; padding: 0; color: white; background-color: black; border: 3px solid white;">
        <img src="assets\infinite-note\pen.svg" alt="Pen" style="height: 2.5em;"></svg>
    </button>
    <button id="eraserButton" style="position: absolute; width: 3em; height: 3em; left: 20em; top: 1em; padding: 0; color: black; background-color: rgb(255, 189, 189); border: 3px solid rgba(0, 0, 0, 0);">
        <img src="assets\infinite-note\eraser.svg" alt="Eraser" style="height: 2.5em;"></svg>
    </button>
    <button id="splitVerticallyButton" style="position: absolute; width: 3em; height: 3em; left: 25em; top: 1em; padding: 0; color: black; background-color: rgb(228, 228, 228); border: 3px solid rgba(0, 0, 0, 0);">
        <img src="assets\infinite-note\split-vertically.svg" alt="Move ↕" style="height: 2.5em;"></svg>
    </button>

    <button id="undoButton" style="position: absolute; width: 3em; height: 3em; left: 1em; bottom: 18em; padding: 0; color: white; background-color: rgba(0, 0, 0, 0); border: 3px solid white;">
        <img src="assets\infinite-note\undo.svg" alt="Pen" style="height: 1.7em;"></svg>
    </button>
    <button id="redoButton" style="position: absolute; width: 3em; height: 3em; left: 1em; bottom: 13em; padding: 0; color: white; background-color: rgba(0, 0, 0, 0); border: 3px solid white;">
        <img src="assets\infinite-note\redo.svg" alt="Pen" style="height: 1.7em;"></svg>
    </button>

    <button id="blackButton" style="position: absolute; background-color: black; border: 3px solid white;"></button>
    <button id="redButton" style="position: absolute; background-color: red; border: 3px solid rgba(0, 0, 0, 0);"></button>
    <button id="yellowButton" style="position: absolute; background-color: rgb(255, 230, 0); border: 3px solid rgba(0, 0, 0, 0);"></button>
    <button id="greenButton" style="position: absolute; background-color: rgb(53, 226, 0); border: 3px solid rgba(0, 0, 0, 0);"></button>
    <button id="blueButton" style="position: absolute; background-color: rgb(0, 119, 255); border: 3px solid rgba(0, 0, 0, 0);"></button>
    <button id="purpleButton" style="position: absolute; background-color: rgb(162, 0, 255); border: 3px solid rgba(0, 0, 0, 0);"></button>
    
    <button id="grayButton" style="position: absolute; background-color: rgb(150, 150, 150); border: 3px solid rgba(0, 0, 0, 0);"></button>
    <button id="orangeButton" style="position: absolute; background-color: rgb(255, 123, 0); border: 3px solid rgba(0, 0, 0, 0);"></button>
    <button id="yellowGreenButton" style="position: absolute; background-color: rgb(166, 255, 0); border: 3px solid rgba(0, 0, 0, 0);"></button>
    <button id="greenBlueButton" style="position: absolute; background-color: rgb(0, 202, 185); border: 3px solid rgba(0, 0, 0, 0);"></button>
    <button id="pureBlueButton" style="position: absolute; background-color: blue; border: 3px solid rgba(0, 0, 0, 0);"></button>
    <button id="roseButton" style="position: absolute; background-color: rgb(255, 0, 140); border: 3px solid rgba(0, 0, 0, 0);"></button>
    
    <!-- <p id="console1" style="position: absolute;"></p> -->
    <!-- <p id="console2"></p> -->

    <script>

        var db;  // indexedDB database
        var document_name;
        // var objectStore;
        var request = indexedDB.open("infinite note");
        request.onsuccess = function(event)
        {
            db = event.target.result;

            const queryString = window.location.search;
            const params = new URLSearchParams(queryString);
            document_name = params.get("name");
            if(document_name==null)
            {
                var i;
                for(i=1;document_exists("Untitled note "+i);i++);
                document_name = "Untitled note "+i;
            }
            console.log(document_name);

            open_document(document_name);

            refresh_canvas();
        };

        function do_something_with_updating_version_of_database(f)
        {
            if(db)
                db.close();
            const request = indexedDB.open("infinite note");
            request.onsuccess = function(event)
            {
                const db = event.target.result;
                const version = db.version;
                db.close();
                const request = indexedDB.open("infinite note", version+1);
                request.onupgradeneeded = function(event)
                {
                    f(event.target.result);
                };
                request.onsuccess = function (event) {
                    const db = event.target.result;
                };
            };
            request.onerror = function (event) {
                console.error(event.target.error);

                state_bar.innerHTML = "Document save failed.";
                state_bar.style.color = bad_state_color;
                show_state_bar();
                succeed_state_showed = false;
            };
        }

        function get_stroke_boundary(stroke)
        {
            var x_min = Infinity;
            var y_min = Infinity;
            var x_max = -Infinity;
            var y_max = -Infinity;

            stroke.points.forEach(point=>
            {
                x_min = Math.min(x_min, point[0]);
                y_min = Math.min(y_min, point[1]);
                x_max = Math.max(x_max, point[0]);
                y_max = Math.max(y_max, point[1]);
            });

            return [[x_min, y_min], [x_max, y_max]];
        }

        function get_document_boundary()
        {
            var x_min = Infinity;
            var y_min = Infinity;
            var x_max = -Infinity;
            var y_max = -Infinity;

            strokes.forEach(stroke=>
            {
                const stroke_boundary = get_stroke_boundary(stroke);

                x_min = Math.min(x_min, stroke_boundary[0][0]);
                y_min = Math.min(y_min, stroke_boundary[0][1]);
                x_max = Math.max(x_max, stroke_boundary[1][0]);
                y_max = Math.max(y_max, stroke_boundary[1][1]);
            });

            return [[x_min, y_min], [x_max, y_max]];
        }

        function generate_json()
        {
            return JSON.stringify(
            {
                "time": new Date().getTime(),
                "strokes": strokes
            });
        }

        function generate_pdf()
        {
            const output_resize = 1.0;

            const document_boundary = get_document_boundary();
            // console.log(document_boundary);
            const offset_x = -document_boundary[0][0]+output_padding;
            const offset_y = -document_boundary[0][1]+output_padding;
            const document_width = document_boundary[1][0]-document_boundary[0][0];
            const document_height = document_boundary[1][1]-document_boundary[0][1];

            const doc = new jsPDF(
                {
                    unit: "pt",
                    format:
                    [
                        document_width+output_padding*2,
                        document_height+output_padding*2
                    ],
                    orientation: document_width<=document_height?"portrait":"landscape"
                }
            );

            doc.setLineWidth(stroke_thickness);
            // doc.setLineMiterLimit(stroke_miter_limit);  // This is not supported by jsPDF 1.5.3.
            strokes.forEach(stroke=>
            {
                doc.setDrawColor(stroke.color?stroke.color:"black");
                const steps = [];
                for(var i=1; i<stroke.points.length; i++)
                    steps.push(vector_subtract(stroke.points[i], stroke.points[i-1]));
                doc.lines(steps, (stroke.points[0][0]+offset_x)*output_resize, (stroke.points[0][1]+offset_y)*output_resize, [output_resize, output_resize], "S");
            });

            // doc.save("a4.pdf");

            return doc.output("blob");
        }

        function document_exists_localStorage(name)
        {
            return localStorage.getItem("infinite_note/"+name)? true: false;
        }

        function document_exists_indexedDB(name)
        {
            return (db&&db.objectStoreNames.contains(name))? true: false;
        }

        function document_exists(name)
        {
            return document_exists_localStorage(name)||document_exists_indexedDB(name);
        }

        function open_document(name)
        {
            var data = localStorage.getItem("infinite_note/"+name);
            if(data)
            {
                initialize_document(JSON.parse(data));
                save_document(name);
                return;
            }

            // console.log(document_exists_indexedDB(name));
            if(document_exists_indexedDB(name))
            {
                const transaction = db.transaction([name], 'readwrite');
                const objectStore = transaction.objectStore(name);

                database_item_id = 1;
                var data = {strokes: []};
                const cursorRequest = objectStore.openCursor();
                cursorRequest.onsuccess = function (event) {
                    const cursor = event.target.result;
                    if (cursor) {
                        const item = cursor.value;
                        database_item_id = Math.max(database_item_id, item.id+1);
                        // console.log(item);
                        switch(item.type)
                        {
                            case "metadata":
                                break;

                            case "stroke":
                                delete item.type;
                                data.strokes.push(item)
                                break;
                        }

                        cursor.continue(); // Move to the next item
                    } else {
                        // console.log(database_item_id);
                        initialize_document(data);
                    }
                };
                return;
            }
        }

        function delete_document_localStorage(name)
        {
            localStorage.removeItem('infinite_note/'+name);
        }

        function delete_document_indexedDB(name)
        {
            do_something_with_updating_version_of_database((e)=>
            {
                e.deleteObjectStore(name);
                db = e;
            });
        }

        function delete_document()
        {
            strokes = [];
            refresh_canvas();

            if(document_exists_localStorage(document_name))
                delete_document_localStorage(document_name);

            if(document_exists_indexedDB(document_name))
                delete_document_indexedDB(document_name);
        }

        function rename_document(new_name)
        {
            do_something_with_updating_version_of_database(e=>
            {
                db = e;
                db.createObjectStore(new_name, { keyPath: 'id' });

                setTimeout(() => {
                    const transaction = db.transaction([document_name, new_name], 'readwrite');
                    const oldObjectStore = transaction.objectStore(document_name);
                    const newObjectStore = transaction.objectStore(new_name);

                    const cursorRequest = oldObjectStore.openCursor();

                    cursorRequest.onsuccess = function (event) {
                        const cursor = event.target.result;

                        if (cursor) {
                            newObjectStore.add(cursor.value);
                            cursor.continue();
                        }
                    };

                    transaction.oncomplete = function () {
                        delete_document_indexedDB(document_name);
                        document_name = new_name;
                    };
                }, 10);
            });
        }

        var database_item_id = 1;

        function document_add_content(data, type)
        {
            data.id = database_item_id++;
            if(!document_exists_indexedDB(document_name))
            {
                do_something_with_updating_version_of_database(e=>
                {
                    db = e;
                    db.createObjectStore(document_name, { keyPath: 'id' });

                    setTimeout(() => {
                        const transaction = db.transaction([document_name], 'readwrite');
                        const objectStore = transaction.objectStore(document_name);

                        const item = {...data};
                        item.type = type;
                        const addRequest = objectStore.add(item);
                        addRequest.onsuccess = function (event) {
                            if(!succeed_state_showed)
                            {
                                succeed_state_showed = true;
                                state_bar.innerHTML = "Successfully saved.";
                                state_bar.style.color = good_state_color;
                                show_state_bar();
                            }
                        };
                        addRequest.onerror = function (event) {
                            console.error('Error adding JSON data:', event.target.error);
                        
                            state_bar.innerHTML = "Document save failed.";
                            state_bar.style.color = bad_state_color;
                            show_state_bar();
                            succeed_state_showed = false;
                        };
                    }, 10);
                });
            }
            else
            {
                const item = {...data};
                item.type = type;
                const transaction = db.transaction([document_name], 'readwrite');
                const objectStore = transaction.objectStore(document_name);
                // console.log(objectStore);
                const addRequest = objectStore.add(item);
                addRequest.onsuccess = function (event) {
                    if(!succeed_state_showed)
                    {
                        succeed_state_showed = true;
                        state_bar.innerHTML = "Successfully saved.";
                        state_bar.style.color = good_state_color;
                        show_state_bar();
                    }
                };
                addRequest.onerror = function (event) {
                    console.error('Error adding JSON data:', event.target.error);
                
                    state_bar.innerHTML = "Document save failed.";
                    state_bar.style.color = bad_state_color;
                    show_state_bar();
                    succeed_state_showed = false;
                };
            }
        }

        function document_edit_contents(data, type)
        {
            if(!document_exists_indexedDB(document_name))
                return;

            const transaction = db.transaction([document_name], 'readwrite');
            const objectStore = transaction.objectStore(document_name);
            data.forEach(e=>
            {
                const item = {...e};
                item.type = type;
                const addRequest = objectStore.put(item);
                addRequest.onsuccess = function (event) {};
                addRequest.onerror = function (event) {
                    console.error('Error adding JSON data:', event.target.error);
                
                    state_bar.innerHTML = "Document save failed.";
                    state_bar.style.color = bad_state_color;
                    show_state_bar();
                    succeed_state_showed = false;
                };
            });
        }

        function document_delete_stroke(stroke)
        {
            const transaction = db.transaction([document_name], 'readwrite');
            const objectStore = transaction.objectStore(document_name);
            const addRequest = objectStore.delete(stroke.id);
        }

        function save_to_database()
        {
            database_item_id = 1;
            document_add_content(
            {
                type:"metadata",
                "time": new Date().getTime()
            }, "metadata");

            strokes.forEach(e=>
            {
                document_add_content(e, "stroke");
            });
        }

        function save_document(name)
        {
            // localStorage.setItem('infinite_note/'+name, generate_json());

            if(document_exists_localStorage(name))
                delete_document_localStorage(name)

            if(!document_exists_indexedDB(name))
            {
                do_something_with_updating_version_of_database(e=>
                {
                    db = e;
                    db.createObjectStore(name, { keyPath: 'id' });
                    setTimeout(() => {
                        const transaction = db.transaction([name], 'readwrite');
                        const objectStore = transaction.objectStore(name);

                        save_to_database();
                    }, 10);
                });
            }
            else
            {
                const transaction = db.transaction([document_name], 'readwrite');
                const objectStore = transaction.objectStore(document_name);
                const request = objectStore.openCursor();
                request.onsuccess = function (event)
                {
                    const cursor = event.target.result;

                    if(cursor)
                    {
                        cursor.delete();
                        cursor.continue();
                    }
                    else  // Already deleted all items
                    {
                        save_to_database();
                    }
                };
            }
        }

        const canvas = document.getElementById('drawingCanvas');

        // const my_console1 = document.getElementById('console1');
        // const my_console2 = document.getElementById('console2');
        // my_console1.innerHTML = "Version 3";
        // my_console1.innerHTML = window.devicePixelRatio;

        canvas.width = window.innerWidth*window.devicePixelRatio;
        canvas.height = window.innerHeight*window.devicePixelRatio;
        const ctx = canvas.getContext('2d');
        ctx.imageSmoothingEnabled = true;

        var eraser_radius = 3*window.devicePixelRatio;

        var mouse_x, mouse_y;
        var is_drawing = false;
        var is_moving_canvas = false;
        var tool = "pen";
        var pen_color = "black";
        var operation_details;

        canvas.width = window.innerWidth*window.devicePixelRatio;
        canvas.height = window.innerHeight*window.devicePixelRatio;

        //Display parameters
        var stroke_thickness = 3;
        var stroke_miter_limit = 2;
        var canvas_offset = [Math.round(canvas.width*0.1)+0.5, 0.5];

        //Output parameters
        var output_padding = 40*window.devicePixelRatio;  // Used for sharing document as PDF file etc..

        // var stroke_count = 0;
        var strokes = [];

        function refresh_canvas()
        {
            clear_canvas();

            // Reference lines
            ctx.strokeStyle = "#222222";
            ctx.lineWidth = 1;
            ctx.setLineDash([4*window.devicePixelRatio, 10*window.devicePixelRatio]);
            ctx.beginPath();
            ctx.moveTo(Math.round(canvas_offset[0])+0.5, canvas_offset[1]%(14*window.devicePixelRatio)/*period of dashed line*/-14*window.devicePixelRatio);
            ctx.lineTo(Math.round(canvas_offset[0])+0.5, canvas.height);
            ctx.stroke();
            ctx.closePath();
            if(is_drawing)
                switch(tool)
                {
                    case "split vertically":
                        ctx.beginPath();
                        ctx.moveTo(0, operation_details.start_y+0.5);
                        ctx.lineTo(canvas.width, operation_details.start_y+0.5);
                        ctx.stroke();
                        ctx.closePath();

                        ctx.beginPath();
                        ctx.moveTo(0, mouse_y+0.5);
                        ctx.lineTo(canvas.width, mouse_y+0.5);
                        ctx.stroke();
                        ctx.closePath();
                        break;
                }

            // Strokes
            ctx.setLineDash([]);
            ctx.lineWidth = stroke_thickness;
            ctx.miterLimit = stroke_miter_limit;
            strokes.forEach(stroke=>
            {
                // console.log(stroke["color"]?stroke["color"]:"black")
                ctx.strokeStyle = stroke["color"]?stroke["color"]:"black";
                const points = stroke["points"];
                // console.log(points);
                ctx.beginPath();
                ctx.moveTo(points[0][0]+canvas_offset[0], points[0][1]+canvas_offset[1]);
                for(var i=1;i<points.length;i++)
                {
                    ctx.lineTo(points[i][0]+canvas_offset[0], points[i][1]+canvas_offset[1]);
                }
                ctx.stroke();
                ctx.closePath();
            });
            ctx.strokeStyle = pen_color;
        }

        function initialize_document(data)
        {
            if(data["strokes"]==undefined)
                return;
            strokes = data["strokes"];
            refresh_canvas();
        }

        function initialize_document_with_json(data)
        {
            initialize_document(JSON.parse(data));
        }

        var last_x, last_y;

        function vector_subtract(u, v)
        {
            return [u[0]-v[0], u[1]-v[1]]
        }

        function vector_scale(k, v)
        {
            return [k*v[0], k*v[1]];
        }

        function vector_length(v)
        {
            return Math.sqrt(v[0]*v[0]+v[1]*v[1]);
        }

        function vector_dot(u, v)
        {
            return u[0]*v[0]+u[1]*v[1];
        }

        function vector_cross(u, v)
        {
            return u[0]*v[1]-u[1]*v[0];
        }

        function distance_to_line(x, y, line_start, line_end)
        {
            const p = [x, y];
            const v = vector_subtract(line_start, line_end);
            const l = vector_length(v);
            const a = vector_subtract(line_start, p);
            if(l==0.)
                return vector_length(a);
            const t = vector_dot(a, v)/(l*l);
            if(t<=0.)
                return vector_length(a);
            const b = vector_subtract(line_end, p);
            if(t>=1.)
                return vector_length(b);
            // console.log(Math.abs(vector_cross(a, b))/l);
            return Math.abs(vector_cross(a, b))/l;
        }

        function near_line(x, y, line_start, line_end, distance)
        {
            return distance_to_line(x, y, line_start, line_end)<=distance;
        }

        function near_polyline(x, y, polyline, distance)
        {
            for(var i=1;i<polyline.length;i++)
                if(near_line(x, y, polyline[i-1], polyline[i], distance))
                    return true;
            return false;
        }

        var erased_strokes;

        function erase(x, y)
        {
            var need_refresh = false;
            for(var i=0;i<strokes.length;i++)
            {
                if(near_polyline(x, y, strokes[i]["points"], eraser_radius))
                {
                    document_delete_stroke(strokes[i]);
                    erased_strokes.push(strokes[i]);
                    strokes.splice(i, 1);
                    i --;
                    need_refresh = true;
                } 
            }
            return need_refresh;
        }

        function start_drawing(e) {
            // console.log(e);
            // ctx.lineWidth = 6*e.pressure;
            
            hide_menus();

            const x = e.clientX*window.devicePixelRatio;
            const y = e.clientY*window.devicePixelRatio;
            const x_on_canvas = x-canvas_offset[0];
            const y_on_canvas = y-canvas_offset[1];

            mouse_x = x;
            mouse_y = y;

            // e.stopPropagation();
            // e.preventDefault();
            // my_console1.innerHTML = "startDrawing";
            // my_console2.innerHTML = tap_count++;
            // my_console1.innerHTML = e.pointerType;
            if(e.pointerType=='pen'||(e.pointerType=='mouse'&&e.button==0))
            {
                switch(tool)
                {
                    case "pen":
                        strokes.push(
                        {
                            "points": [[x_on_canvas, y_on_canvas]],
                            "color": pen_color
                        });
                        is_drawing = true;
                        ctx.beginPath();
                        ctx.moveTo(x, y);
                        break;

                    case "eraser":
                        erased_strokes = [];
                        is_drawing = true;
                        const need_refresh = erase(x_on_canvas, y_on_canvas);
                        if(need_refresh)
                            refresh_canvas();
                        break;

                    case "split vertically":
                        is_drawing = true;
                        operation_details =
                        {
                            strokes_below: [],
                            start_y: y
                        };
                        strokes.forEach(stroke=>
                        {
                            if(stroke.points[0][1]>=y_on_canvas)
                                operation_details.strokes_below.push(stroke);
                        });
                        refresh_canvas();
                        break;
                }
                
            }
            else  // Drag canvas
            {
                last_x = x;
                last_y = y;
                is_moving_canvas = true;
            }
        }

        function pointer_move(e) {
            const x = e.clientX*window.devicePixelRatio;
            const y = e.clientY*window.devicePixelRatio;
            const x_on_canvas = x-canvas_offset[0];
            const y_on_canvas = y-canvas_offset[1];
            const movement_y = y-mouse_y;

            mouse_x = x;
            mouse_y = y;

            // e.stopPropagation();
            // e.preventDefault();
            if (is_drawing)
            {
                // my_console1.innerHTML = "drawing";
                switch(tool)
                {
                    case "pen":
                        strokes[strokes.length-1]["points"].push([x_on_canvas, y_on_canvas]);
                        ctx.lineTo(x, y);
                        ctx.stroke();
                        break;

                    case "eraser":
                        const need_refresh = erase(x_on_canvas, y_on_canvas);
                        if(need_refresh)
                            refresh_canvas();
                        break;

                    case "split vertically":
                        // state_bar.innerHTML = e.movementY;
                        // show_state_bar();
                        operation_details.strokes_below.forEach(stroke=>
                        {
                            stroke.points.forEach(point=>
                            {
                                point[1] += movement_y;
                            });
                        });
                        if(movement_y!=0)
                            refresh_canvas();
                        break;
                }
            }
            else if(is_moving_canvas)
            {
                canvas_offset[0] += x-last_x;
                canvas_offset[1] += y-last_y;
                refresh_canvas();
            }

            last_x = x;
            last_y = y;
        }

        function stop_drawing(e) {
            // e.stopPropagation();
            // e.preventDefault();
            // if(isDrawing)
                // my_console1.innerHTML = "stopDrawing";
            is_moving_canvas = false;
            
            if(is_drawing)
            {
                is_drawing = false;
                switch(tool)
                {
                    case "pen":
                        ctx.closePath();
                        document_add_content(strokes[strokes.length-1], "stroke");
                        record({
                            type: "add stroke",
                            stroke: strokes[strokes.length-1]
                        });
                        break;

                    case "eraser":
                        if(erased_strokes.length>0)
                            record({
                                type: "delete strokes",
                                strokes: [... erased_strokes]
                            });
                        break;

                    case "split vertically":
                        document_edit_contents(operation_details.strokes_below, "stroke");
                        refresh_canvas();
                        record({
                            type: "move strokes",
                            strokes: [... operation_details.strokes_below],
                            movement: [0, mouse_y-operation_details.start_y]
                        });
                        break;
                }
            }
        }

        function clear_canvas() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
        }

        // document.addEventListener('pointerdown', startDrawing);
        // document.addEventListener('pointermove', draw);
        // document.addEventListener('pointerup', stopDrawing);
        // document.addEventListener('pointercancel', stopDrawing);

        function put_under_an_element(element_to_put, reference_element, offset)
        {
            const bounding = reference_element.getBoundingClientRect();
            element_to_put.style.left = bounding.left+offset[0]+"px";
            element_to_put.style.top = bounding.bottom+offset[1]+"px";
        }
        
        const state_bar = document.getElementById('state');
        const file_menu = document.getElementById('fileMenu');
        const pen_button = document.getElementById('penButton');
        const eraser_button = document.getElementById('eraserButton');
        const split_vertically_button = document.getElementById('splitVerticallyButton');
        const color_buttons =
        [
            document.getElementById('blackButton'),
            document.getElementById('grayButton'),
            document.getElementById('redButton'),
            document.getElementById('orangeButton'),
            document.getElementById('yellowButton'),
            document.getElementById('yellowGreenButton'),
            document.getElementById('greenButton'),
            document.getElementById('greenBlueButton'),
            document.getElementById('blueButton'),
            document.getElementById('pureBlueButton'),
            document.getElementById('purpleButton'),
            document.getElementById('roseButton')
        ];
        const colors = [
            "black",
            "rgb(150, 150, 150)",
            "red",
            "rgb(255, 123, 0)",
            "rgb(255, 230, 0)",
            "rgb(166, 255, 0)",
            "rgb(53, 226, 0)",
            "rgb(0, 202, 185)",
            "rgb(0, 119, 255)",
            "blue",
            "rgb(162, 0, 255)",
            "rgb(255, 0, 140)"
        ];
        const file_button = document.getElementById('fileButton');

        function hide_menus()
        {
            file_menu.style.display = "none";
        }

        file_button.addEventListener('click', ()=>
        {
            const displaying = file_menu.style.display=="block";
            hide_menus();
            if(!displaying)
            {
                put_under_an_element(file_menu, file_button, [10, 10]);
                file_menu.style.display = "block";
            }
        });

        document.getElementById('deleteDocument').addEventListener('click', ()=>
        {
            const bo = (!document_exists(document_name))||window.confirm("Are you sure you want to delete the document?");
            
            if(bo)
            {
                delete_document(document_name);
            }
            hide_menus();
        });

        document.getElementById('renameDocument').addEventListener('click', ()=>
        {
            const userInput = prompt("New name:");

            if (userInput !== null)
            {
                if(document_exists(userInput))
                    window.alert('Renaming failed because document with that name already exists.');
                else
                {
                    if(document_exists(document_name))
                        rename_document(userInput);
                    else  // The document is currently empty.
                        document_name = userInput;
                }
            }
            
            hide_menus();
        });

        document.getElementById('shareJSON').addEventListener('click', ()=>
        {
            hide_menus();
            if (navigator.share)
            {
                const blob = new Blob([generate_json()], { type: 'text/plain' });
                try {
                    navigator.share({
                        title: document_name,
                        text: 'Shared with Infinite Note',
                        files: [new File([blob], document_name+'.json')],
                    });
                } catch (error) {
                    console.error('Error sharing:', error);
                    state_bar.innerHTML = "Share failed.";
                    state_bar.style.color = bad_state_color;
                    show_state_bar();
                }
            } else {
                alert('Your browser does not support the Web Share API.');
            }
        });

        document.getElementById('sharePDF').addEventListener('click', ()=>
        {
            hide_menus();
            
            if (navigator.share)
            {
                const blob = generate_pdf();
                try {
                    navigator.share({
                        title: document_name,
                        text: 'Shared with Infinite Note',
                        files: [new File([blob], document_name+'.pdf')],
                    });
                } catch (error) {
                    console.error('Error sharing:', error);
                    state_bar.innerHTML = "Share failed.";
                    state_bar.style.color = bad_state_color;
                    show_state_bar();
                }
            } else {
                alert('Your browser does not support the Web Share API.');
            }
        });

        document.getElementById('toJSON').addEventListener('click', ()=>
        {
            hide_menus();
            navigator.clipboard.writeText(generate_json())
            .then(() => {
                console.log('Text copied to clipboard');
            })
            .catch((error) => {
                console.error('Clipboard API error:', error);
                
                state_bar.innerHTML = "Document save failed.";
                state_bar.style.color = bad_state_color;
                show_state_bar();
                succeed_state_showed = false;
            });
        });

        document.getElementById('fromJSON').addEventListener('click', ()=>
        {
            const bo = (!document_exists(document_name))||window.confirm("This action will overwrite the contents of the current document. Are you sure that's what you want?");
            
            if(bo)
            {
                setTimeout(function()
                {
                    navigator.clipboard.readText()
                    .then((clipboardText) => {
                        initialize_document_with_json(clipboardText);
                        save_document(document_name);
                    })
                    .catch((error) => {
                        console.error('Clipboard API error:', error);
                        
                        state_bar.innerHTML = "Document save failed.";
                        state_bar.style.color = bad_state_color;
                        show_state_bar();
                        succeed_state_showed = false;
                    });
                }, 10);
            }

            hide_menus();
            
        });

        pen_button.addEventListener('click', ()=>
        {
            hide_menus();
            tool = "pen";
            pen_button.style.border = "3px solid white";
            eraser_button.style.border = "3px solid rgba(0, 0, 0, 0)";
            split_vertically_button.style.border = "3px solid rgba(0, 0, 0, 0)";
        });
        
        eraser_button.addEventListener('click', ()=>
        {
            hide_menus();
            tool = "eraser";
            pen_button.style.border = "3px solid rgba(0, 0, 0, 0)";
            eraser_button.style.border = "3px solid white";
            split_vertically_button.style.border = "3px solid rgba(0, 0, 0, 0)";
        });
        
        split_vertically_button.addEventListener('click', ()=>
        {
            hide_menus();
            tool = "split vertically";
            pen_button.style.border = "3px solid rgba(0, 0, 0, 0)";
            eraser_button.style.border = "3px solid rgba(0, 0, 0, 0)";
            split_vertically_button.style.border = "3px solid white";
        });

        var action_history = [];
        var time_step = -1;

        function record(action)
        {
            action_history = action_history.slice(0, time_step+1);
            action_history.push(action);
            time_step ++;
        }

        document.getElementById('undoButton').addEventListener('click', ()=>
        {
            if(time_step>=0)
            {
                const action = action_history[time_step];
                switch(action.type)
                {
                    case "add stroke":
                        var i;
                        for(i=0; i<strokes.length; i++)
                            if(strokes[i].id==action.stroke.id)
                                break;
                        document_delete_stroke(strokes[i]);
                        strokes.splice(i, 1);
                        break;
                        
                    case "delete strokes":
                        strokes = strokes.concat(action.strokes);
                        action.strokes.forEach(stroke=>
                        {
                            document_add_content(stroke, "stroke");
                        });
                        break;
                        
                    case "move strokes":
                        action.strokes.forEach(stroke=>
                        {
                            stroke.points.forEach(point=>
                            {
                                point[0] -= action.movement[0];
                                point[1] -= action.movement[1];
                            });
                        });
                        document_edit_contents(action.strokes, "stroke");
                        break;
                }

                time_step --;

                refresh_canvas();
            }
        });

        document.getElementById('redoButton').addEventListener('click', ()=>
        {
            if(time_step+1<action_history.length)
            {
                time_step ++;
                const action = action_history[time_step];

                switch(action.type)
                {
                    case "add stroke":
                        strokes.push(action.stroke);
                        document_add_content(action.stroke, "stroke");
                        break;
                        
                    case "delete strokes":
                        action.strokes.forEach(stroke=>
                        {
                            var i;
                            for(i=0; i<strokes.length; i++)
                                if(strokes[i].id==stroke.id)
                                    break;
                            document_delete_stroke(strokes[i]);
                            strokes.splice(i, 1);
                        });
                        break;
                        
                    case "move strokes":
                        action.strokes.forEach(stroke=>
                        {
                            stroke.points.forEach(point=>
                            {
                                point[0] += action.movement[0];
                                point[1] += action.movement[1];
                            });
                        });
                        document_edit_contents(action.strokes, "stroke");
                        break;
                }

                refresh_canvas();
            }
        });

        for(var i=0; i<color_buttons.length; i++)
        {
            color_buttons[i].style.left = 39+2*i-(i%2==0?1.5:0.75)+"em";
            color_buttons[i].style.top = (i%2==0?1:3.5)+"em";
            color_buttons[i].style.width = (i%2==0?3:1.5)+"em";
            color_buttons[i].style.height = (i%2==0?3:1.5)+"em";
            color_buttons[i].style.padding = 0;

            const i_const = i;
            color_buttons[i].addEventListener('click', ()=>
            {
                hide_menus();
                pen_color = colors[i_const];
                ctx.strokeStyle = pen_color;
                color_buttons[i_const].style.border = "3px solid white";
                for(var j=0; j<color_buttons.length; j++)
                    if(j!=i_const)
                        color_buttons[j].style.border = "3px solid rgba(0, 0, 0, 0)";
            });
        }

        $('#drawingCanvas').on('pointerdown', start_drawing);
        $('#drawingCanvas').on('pointermove', pointer_move);
        $('#drawingCanvas').on('pointerup', stop_drawing);
        $('#drawingCanvas').on('pointercancel', stop_drawing);
        $('#drawingCanvas').on('click touchend', (e)=>
        {
            e.stopPropagation();
            e.preventDefault();
        });

        var state_fading_out = false;

        function fade_out(element, waiting_time, fading_out_speed, on_finished)
        {
            if(waiting_time>0)
                setTimeout((function()
                {
                    fade_out(element, 0, fading_out_speed, on_finished);
                }), waiting_time);
            else
            {
                const opacity = Math.max(0, element.style.opacity-fading_out_speed*0.03);
                element.style.opacity = opacity;
                if(opacity>0)
                    setTimeout((function()
                    {
                        fade_out(element, 0, fading_out_speed, on_finished);
                    }), 30);
                else
                    if(on_finished)
                        on_finished();
            }

        }
        
        var good_state_color = "rgb(82, 153, 85)";
        var bad_state_color = "red";

        var succeed_state_showed = false;

        function show_state_bar()
        {
            state_bar.style.opacity = 1;
            if(!state_fading_out)
            {
                state_fading_out = true;
                fade_out(state_bar, 1000, 0.3, ()=>{
                    state_fading_out = false;
                });
            }
        }

    </script>
</body>
</html>
