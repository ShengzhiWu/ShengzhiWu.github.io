<!DOCTYPE html>
<html lang="zh">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pyrite Crystal</title>
    <style>
        * {
            margin: 0;
            padding: 0;
        }

        body {
            overflow: hidden;
            width: 100vw;
            height: 100vh;
            background: rgb(255, 255, 255);
        }

        .split-container {
            display: flex;
            flex-direction: row;
            /* é»˜è®¤æ¨ªå‘æ’åˆ— */
            width: 100%;
            height: 100%;
        }

        .split-part {
            flex: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: hidden;
            border: solid 1px rgba(0, 0, 0, 0.068);
            box-shadow: inset 0 0 calc(min(100vmin, 100vmax / 2) * 0.2) rgba(0, 0, 0, 0.3);
        }

        .part-2 svg {
            width: 100%;
            height: 100%;
            object-fit: contain;
        }

        /* ç¬¬ä¸€éƒ¨åˆ†é»˜è®¤é¡ºåº */
        .part-1 {
            order: 1;
        }

        /* ç¬¬äºŒéƒ¨åˆ†é»˜è®¤é¡ºåº */
        .part-2 {
            order: 2;
        }

        /* çºµå‘æ’åˆ—æ—¶çš„æ ·å¼ */
        .split-container.vertical {
            flex-direction: column;
        }

        /* çºµå‘æ—¶å¼ºåˆ¶æ¯éƒ¨åˆ†é«˜åº¦ä¸º50% */
        .split-container.vertical .split-part {
            flex: none;
            height: 50%;
            width: 100%;
        }

        /* çºµå‘æ—¶äº¤æ¢é¡ºåº */
        .split-container.vertical .part-1 {
            order: 2;
        }

        .split-container.vertical .part-2 {
            order: 1;
            position: relative;
        }

        /* æ–¹å½¢ï¼Œå¡«æ»¡åŠè¾¹ */
        .square-container {
            width: calc(min(100vmin, 100vmax / 2));
            aspect-ratio: 1 / 1;
            position: absolute;
        }

        .square-container svg {
            position: absolute;
        }

        #pin {
            position: absolute;
            pointer-events: none;
            transform: translate(-50%, -100%);
            /* å°†å®šä½ä¸­å¿ƒç§»åˆ°å°–ç«¯ */
        }

        /* æŒ‰é’® */
        .button {
            position: absolute;
            width: 3em;
            aspect-ratio: 1 / 1;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.8);
            border: 2px solid #333;
            /* box-shadow: 0 0 5px rgba(0, 0, 0, 0.3); */
            box-shadow: inset 0 0 0.8em rgba(0, 0, 0, 0.2);
            cursor: pointer;
            display: flex;
            justify-content: center;
            align-items: center;
            transition: all 0.2s ease;
        }

        .button:hover {
            transform: scale(1.05);
        }

        .button.pressed {
            background: rgba(200, 230, 255, 0.8);
        }

        /* æŒ‰ä¸‹çš„ç¬é—´å˜æˆé«˜äº®è‰² */
        #save-button:active {
            background: rgba(200, 230, 255, 0.8);
            transition: background-color 0s ease;
        }

        .button svg {
            width: 60%;
            height: 60%;
        }
    </style>
</head>

<body>
    <div class="split-container">
        <div class="split-part part-1" id="graph-panel">
            <div class="square-container">
                <svg id="graph" style="width: 100%; height: 100%;" xmlns="http://www.w3.org/2000/svg"></svg>
            </div>
        </div>
        <div class="split-part part-2">
            <svg id="scene-svg" xmlns="http://www.w3.org/2000/svg"></svg>

            <!-- è‡ªè½¬æ§åˆ¶æŒ‰é’® -->
            <div class="button pressed" id="rotate-button" style="bottom: 1em; right: 5em;">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path
                        d="M12 4V1L8 5l4 4V6c3.31 0 6 2.69 6 6 0 1.01-.25 1.97-.7 2.8l1.46 1.46A7.93 7.93 0 0020 12c0-4.42-3.58-8-8-8zm0 14c-3.31 0-6-2.69-6-6 0-1.01.25-1.97.7-2.8L5.24 7.74A7.93 7.93 0 004 12c0 4.42 3.58 8 8 8v3l4-4-4-4v3z" />
                </svg>
            </div>

            <!-- ä¿å­˜æ¨¡å‹æŒ‰é’® -->
            <div class="button" id="save-button" style="bottom: 1em; right: 1em;">
                OBJ
            </div>
        </div>
    </div>

    <svg id="pin" width="calc(min(100vmin, 100vmax / 2) * 0.13)" viewBox="-5 -2 40 45.5">
        <!-- æ°´æ»´å½¢å¤§å¤´é’ˆ -->
        <path
            d="M15 0C6.716 0 0 6.716 0 15c0 5.245 3.33 12.306 15 27 11.67-14.694 15-21.755 15-27 0-8.284-6.716-15-15-15z"
            fill="#e74c3caa" stroke="#c0392b" stroke-width="3" />
        <circle cx="15" cy="15" r="8" fill="#fdd" opacity="0.5" />
        <!-- é’ˆå¤´ -->
        <!-- <circle cx="15" cy="39" r="2" fill="#c0392b" /> -->
        <path d="M15 42l-3-3h6z" fill="#c0392b" />
    </svg>

    <!-- å‡ ä½•è®¡ç®—éƒ¨åˆ†ä»£ç  -->
    <script>
        function compute_face_center(face) {  // è®¡ç®—ä¸€ä¸ªé¢çš„ä¸­å¿ƒå¹¶å°†ç»“æœè®°å½•åœ¨é¢æ•°æ®å­—å…¸ä¸­
            const center = { x: 0, y: 0, z: 0 };
            face.points.forEach(point => {
                center.x += point.x;
                center.y += point.y;
                center.z += point.z;
            });
            center.x /= face.points.length;
            center.y /= face.points.length;
            center.z /= face.points.length;
            face.centerPoint = center;
        }

        function addVectors(u, v) {
            return [u[0] + v[0], u[1] + v[1], u[2] + v[2]];
        }

        function subtractVectors(u, v) {
            return [u[0] - v[0], u[1] - v[1], u[2] - v[2]];
        }

        function dotProduct(u, v) {
            return u[0] * v[0] + u[1] * v[1] + u[2] * v[2];
        }

        function vectorLength(v) {
            return dotProduct(v, v) ** 0.5;
        }

        function crossProduct(u, v) {
            return [
                u[1] * v[2] - u[2] * v[1],
                u[2] * v[0] - u[0] * v[2],
                u[0] * v[1] - u[1] * v[0]
            ];
        }

        function scaleVector(v, scale) {  // ç¼©æ”¾ä¸€ä¸ªå‘é‡
            return v.map(a => a * scale);
        }

        function scaleVectors(vertors, scale) {  // ç¼©æ”¾ä¸€ç»„å‘é‡
            return vertors.map(v => scaleVector(v, scale));
        }

        function is_triangle_normal_correct(a, b, c, normal) {
            const u = subtractVectors(b, a);
            const v = subtractVectors(c, b);
            return dotProduct(normal, crossProduct(u, v)) >= -0.0001;
        }

        function mod(a, b) {
            while (a < 0)
                a += b;
            return a % b;
        }

        function sort_face_points(vertices, face, normal) {  // æ’åºä¸€ä¸ªé¢çš„è‹¥å¹²ä¸ªé¡¶ç‚¹ä½¿å¾—å®ƒä»¬å›´æˆä¸€ä¸ªå‡¸å¤šè¾¹å½¢ä¸”æ³•å‘æ­£ç¡®ã€‚è¿™ä¸ªå‡½æ•°æœ‰è½»å¾®çš„bugï¼Œä¸è¿‡å‘ç”Ÿçš„æ¦‚ç‡å¾ˆä½
            const result = [face[0], face[1]];

            for (let i = 2; i < face.length; i++) {
                let j;
                for (j = 0; j < result.length; j++) {
                    let convex = true;
                    for (let k = 0; convex && k < result.length; k++)
                        for (let l = k + 1; convex && l < result.length; l++)
                            if (!is_triangle_normal_correct(
                                vertices[result[mod(j + k, result.length)]],
                                vertices[result[mod(j + l, result.length)]],
                                vertices[face[i]],
                                normal
                            ))
                                convex = false;
                    if (convex)
                        break;

                    // if (!is_triangle_normal_correct(
                    //     vertices[result[mod(j - 2, result.length)]],
                    //     vertices[result[mod(j - 1, result.length)]],
                    //     vertices[face[i]],
                    //     normal
                    // ))
                    //     continue;
                    // if (!is_triangle_normal_correct(
                    //     vertices[result[mod(j - 1, result.length)]],
                    //     vertices[face[i]],
                    //     vertices[result[mod(j, result.length)]],
                    //     normal
                    // ))
                    //     continue;
                    // if (!is_triangle_normal_correct(
                    //     vertices[face[i]],
                    //     vertices[result[mod(j, result.length)]],
                    //     vertices[result[mod(j + 1, result.length)]],
                    //     normal
                    // ))
                    //     continue;
                    // break;
                }
                if (j == result.length)
                    console.log('æœªæ‰¾åˆ°åˆé€‚çš„æ’å…¥ä½ç½®');
                result.splice(j, 0, face[i]);
            }
            let convex = true;
            for (let i = 0; i < face.length; i++)
                if (!is_triangle_normal_correct(
                    vertices[result[i]],
                    vertices[result[mod(i + 1, result.length)]],
                    vertices[result[mod(i + 2, result.length)]],
                    normal
                )) {
                    convex = false;
                }
            if (!convex) {
                console.log('é¢éå‡¸');
                console.log(face.map(i => vertices[i]), normal);
                console.log(result.map(i => vertices[i].map(a => a.toFixed(2))));
            }
            return result;
        }

        /**
        * è®¡ç®—ç”±å¤šä¸ªå¹³é¢åˆ‡å‰²å½¢æˆçš„åŒ…å«åŸç‚¹çš„å‡¸å¤šé¢ä½“
        * @param {Array} planes - å¹³é¢æ•°ç»„ï¼Œæ¯ä¸ªå¹³é¢è¡¨ç¤ºä¸º {normal: [x,y,z], point: [x,y,z]}
        * @returns {Object} - è¿”å›å¤šé¢ä½“å¯¹è±¡ï¼ŒåŒ…å«é¡¶ç‚¹å’Œé¢ä¿¡æ¯
        */

        function calculateConvexPolyhedron(planes) {
            // å°†å¹³é¢è¡¨ç¤ºä¸ºAx + By + Cz + D = 0çš„å½¢å¼
            const normalizedPlanes = planes.map(plane => {
                const [A, B, C] = plane.normal;
                const [x0, y0, z0] = plane.point;
                const D = -(A * x0 + B * y0 + C * z0);
                const length = Math.sqrt(A * A + B * B + C * C);
                return {
                    A: A / length,
                    B: B / length,
                    C: C / length,
                    D: D / length
                };
            });

            // è®¡ç®—æ‰€æœ‰å¹³é¢çš„äº¤ç‚¹ï¼ˆå€™é€‰é¡¶ç‚¹ï¼‰
            const vertices = [];
            for (let i = 0; i < normalizedPlanes.length; i++) {
                for (let j = i + 1; j < normalizedPlanes.length; j++) {
                    for (let k = j + 1; k < normalizedPlanes.length; k++) {
                        const p1 = normalizedPlanes[i];
                        const p2 = normalizedPlanes[j];
                        const p3 = normalizedPlanes[k];

                        // è§£ä¸‰å…ƒä¸€æ¬¡æ–¹ç¨‹ç»„æ±‚äº¤ç‚¹
                        const denominator = p1.A * (p2.B * p3.C - p3.B * p2.C) -
                            p1.B * (p2.A * p3.C - p3.A * p2.C) +
                            p1.C * (p2.A * p3.B - p3.A * p2.B);

                        if (Math.abs(denominator) < 1e-10) continue; // å¹³é¢å¹³è¡Œæˆ–å…±çº¿

                        const D1 = -p1.D;
                        const D2 = -p2.D;
                        const D3 = -p3.D;

                        const x = (D1 * (p2.B * p3.C - p3.B * p2.C) -
                            p1.B * (D2 * p3.C - D3 * p2.C) +
                            p1.C * (D2 * p3.B - D3 * p2.B)) / denominator;

                        const y = (p1.A * (D2 * p3.C - D3 * p2.C) -
                            D1 * (p2.A * p3.C - p3.A * p2.C) +
                            p1.C * (p2.A * D3 - p3.A * D2)) / denominator;

                        const z = (p1.A * (p2.B * D3 - p3.B * D2) -
                            p1.B * (p2.A * D3 - p3.A * D2) +
                            D1 * (p2.A * p3.B - p3.A * p2.B)) / denominator;

                        // æ£€æŸ¥è¯¥ç‚¹æ˜¯å¦åœ¨æ‰€æœ‰å…¶ä»–å¹³é¢çš„"æ­£é¢"ï¼ˆå³æ»¡è¶³Ax + By + Cz + D <= 0ï¼‰
                        let isValid = true;
                        for (let m = 0; m < normalizedPlanes.length; m++) {
                            if (m === i || m === j || m === k) continue;
                            const p = normalizedPlanes[m];
                            const distance = p.A * x + p.B * y + p.C * z + p.D;
                            if (distance > 1e-10) {
                                isValid = false;
                                break;
                            }
                        }

                        if (isValid) {
                            vertices.push({
                                point: [x, y, z],
                                faces: [i, j, k]
                            });
                        }
                    }
                }
            }

            // å»é™¤é‡å¤é¡¶ç‚¹
            const uniqueVertices = [];
            vertices.forEach(v => {
                let j;
                for (j = 0; j < uniqueVertices.length; j++)
                    if (vectorLength(subtractVectors(v.point, uniqueVertices[j].point)) < 0.001) {
                        // uniqueVertices[j].point = scaleVector(addVectors(v.point, uniqueVertices[j].point), 0.5);
                        uniqueVertices[j].faces.push(...v.faces);
                        break;
                    }
                if (j == uniqueVertices.length)
                    uniqueVertices.push(v);
            });

            // æ”¶é›†ä¸æ¯ä¸ªè¾¹å…³è”çš„é¡¶ç‚¹çš„ç¼–å·
            const uniqueVerticesPure = uniqueVertices.map(v => v.point);
            const faces = [];
            for (let i = 0; i < planes.length; i++) {
                let face = [];
                uniqueVertices.forEach((p, j) => {
                    if (p.faces.includes(i))
                        face.push(j);
                });

                if (face.length <= 2)
                    continue;

                // ä¸ºç‚¹æ’åº
                face = sort_face_points(uniqueVerticesPure, face, planes[i].normal);

                faces.push(face);
            }

            return { vertices: uniqueVerticesPure, faces };
        }

        function dictVectorToList(v) {
            return [v.x, v.y, v.z];
        }

        const phi = 2;  // é»„é“çŸ¿äº”è§’åäºŒé¢ä½“{210}æ™¶é¢
        const planeNormals = {  // ä¸åŒçš„æ™¶é¢æŒ‡æ•°å¯¹åº”çš„æ³•å‘æ—
            '100': [  // ç«‹æ–¹ä½“
                [1, 0, 0], [-1, 0, 0],
                [0, 1, 0], [0, -1, 0],
                [0, 0, 1], [0, 0, -1]
            ],
            '111': [  // å…«é¢ä½“
                [1, 1, 1],
                [1, 1, -1],
                [1, -1, 1],
                [1, -1, -1],
                [-1, 1, 1],
                [-1, 1, -1],
                [-1, -1, 1],
                [-1, -1, -1]
            ],
            '210': [  // äº”è§’åäºŒé¢ä½“
                [0, 1, phi], [0, 1, -phi], [0, -1, phi], [0, -1, -phi],
                [1, phi, 0], [1, -phi, 0], [-1, phi, 0], [-1, -phi, 0],
                [phi, 0, 1], [phi, 0, -1], [-phi, 0, 1], [-phi, 0, -1]
            ]
        };
        Object.keys(planeNormals).forEach(key => {  // å½’ä¸€åŒ–
            const length = vectorLength(planeNormals[key][0]);
            planeNormals[key] = scaleVectors(planeNormals[key], 1 / length);
        });
    </script>

    <!-- 3d ä¸äº¤äº’éƒ¨åˆ†ä»£ç  -->
    <script>
        function getPolygon(distances, color) {
            // æ„é€ å¹³é¢
            let planes = [];
            Object.keys(distances).forEach(key => {
                planes = planes.concat(scaleVectors(planeNormals[key], distances[key]));
            });
            planes = planes.map(point => ({ normal: point, point }));

            // è®¡ç®—å¹³é¢åŒ…å›´çš„å¤šé¢ä½“
            return calculateConvexPolyhedron(planes);
        }

        // ç»•Xè½´æ—‹è½¬ç‚¹ (phi)
        function rotatePhi(x, y, z, angle) {
            const cos = Math.cos(angle);
            const sin = Math.sin(angle);
            return {
                x: x * cos - y * sin,
                y: x * sin + y * cos,
                z: z
            };
        }

        // ç»•Yè½´æ—‹è½¬ç‚¹ (theta)
        function rotateTheta(x, y, z, angle) {
            const cos = Math.cos(angle);
            const sin = Math.sin(angle);
            return {
                x: x * cos - z * sin,
                y: y,
                z: x * sin + z * cos
            };
        }

        // é€è§†æŠ•å½±
        function project(camera, width, height, x, y, z) {
            // è®¡ç®—ç‰©ä½“ç›¸å¯¹äºæ‘„åƒæœºçš„ä½ç½®
            const relX = x - camera.distance;

            // é€è§†æŠ•å½±
            // const scale = Math.max(width, height) / 2 / Math.tan(camera.angle / 2) / relX;
            const scale = (width + height) / 2 / 2 / Math.tan(camera.angle / 2) / relX;
            return {
                x: -y * scale + width / 2,
                y: z * scale + height / 2,
                z: relX
            };
        }

        // æ—‹è½¬ + é€è§†æŠ•å½±
        function processPoint(camera, width, height, p) {
            let rotated = rotatePhi(p.x, p.y, p.z, camera.phi);
            rotated = rotateTheta(rotated.x, rotated.y, rotated.z, camera.theta);
            const rojected = project(camera, width, height, rotated.x, rotated.y, rotated.z)
            return rojected;
        }

        function generateScene(svg, faces, enableInteraction, cameraDistance, cameraAngle, strokeWidth, cameraPhi, cameraTheta) {
            // æ‘„åƒæœºå‚æ•°ï¼ˆçƒåæ ‡ç³»ï¼‰
            let camera = {
                theta: cameraTheta / 180 * Math.PI,  // æ°´å¹³æ—‹è½¬è§’åº¦ (ç»•Yè½´)
                phi: cameraPhi / 180 * Math.PI,  // å‚ç›´æ—‹è½¬è§’åº¦ (ç»•Xè½´)
                distance: cameraDistance, // æ‘„åƒæœºè·ç¦»
                angle: cameraAngle * Math.PI / 180  // æ‘„åƒæœºï¼ˆåœ¨å®½åº¦å’Œé«˜åº¦ä¸­è¾ƒå¤§çš„ä¸€ä¸ªä¸Šçš„ï¼‰è§†è§’
            };

            let faces_local = faces;

            function updateFaces(faces) {
                faces_local = faces;
            }

            // æ¸²æŸ“
            function render() {
                const width = svg.clientWidth;
                const height = svg.clientHeight;

                // æ¸…ç©ºSVG
                svg.innerHTML = '';  // æ¸…ç©º

                // å¤„ç†æ¯ä¸ªé¢çš„é¡¶ç‚¹
                const processedFaces = faces_local.map(face => {
                    const projectedPoints = face.points.map(e => processPoint(camera, width, height, e));

                    // è®¡ç®—ä¸­å¿ƒç‚¹Zåæ ‡ (ç”¨äºæ’åº)
                    let centerZ = processPoint(camera, width, height, face.centerPoint).z;
                    if (is_triangle_normal_correct(dictVectorToList(projectedPoints[0]), dictVectorToList(projectedPoints[1]), dictVectorToList(projectedPoints[2]), [0, 0, 1])) {
                        centerZ -= 100;  // è¯¥é¢èƒŒå¯¹ç›¸æœºï¼Œè¿™ç§æƒ…å†µä¸‹å°†è¯¥é¢çš„æ·±åº¦æ‰‹åŠ¨è®¾æ·±ä»¥é¿å…é”™è¯¯çš„é®æŒ¡å…³ç³»
                    }

                    return {
                        color: face.color,
                        points: projectedPoints,
                        centerZ: centerZ
                    };
                });

                // æŒ‰ä¸­å¿ƒç‚¹Zåæ ‡æ’åº (ä»è¿œåˆ°è¿‘)
                processedFaces.sort((a, b) => a.centerZ - b.centerZ);

                // ç»˜åˆ¶æ¯ä¸ªé¢
                processedFaces.forEach(face => {
                    const polygon = document.createElementNS("http://www.w3.org/2000/svg", "polygon");

                    // æ„å»ºç‚¹å­—ç¬¦ä¸²
                    let pointsStr = '';
                    face.points.forEach(p => {
                        pointsStr += `${p.x},${p.y} `;
                    });
                    polygon.setAttribute("points", pointsStr.trim());

                    polygon.setAttribute("fill", face.color);
                    polygon.setAttribute("stroke", "#000");  // è¾¹ç¼˜çº¿é¢œè‰²
                    polygon.setAttribute("stroke-width", strokeWidth);  // çº¿å®½
                    polygon.setAttribute("stroke-linecap", "round");  // ç«¯ç‚¹åœ†å½¢
                    polygon.setAttribute("stroke-linejoin", "round");  // æ‹è§’åœ†å½¢

                    svg.appendChild(polygon);
                });
            };

            if (enableInteraction) {
                // é¼ æ ‡æ‹–åŠ¨æ—‹è½¬
                let isDragging = false;

                svg.addEventListener('mousedown', (e) => {
                    isDragging = true;
                });

                document.addEventListener('mousemove', (e) => {
                    if (!isDragging) return;

                    camera.phi += e.movementX * 0.01;
                    camera.theta -= e.movementY * 0.01;
                    camera.theta = Math.min(Math.PI / 2, Math.max(-Math.PI / 2, camera.theta));  // é™åˆ¶å‚ç›´è§’åº¦

                    render();
                });

                document.addEventListener('mouseup', () => {
                    isDragging = false;
                });

                svg.addEventListener('wheel', (e) => {
                    camera.distance *= Math.exp(e.deltaY * 0.001);  // æ ¹æ®æ»šè½®æ–¹å‘è°ƒæ•´ç›¸æœºè·ç¦»

                    render();
                });
            }

            return { camera, render, updateFaces };
        }

        const { faces, rawGeometry } = coordinatesToGeometry(0, 0, 'rgba(230, 220, 120, 0.8)');  // åˆå§‹å‡ ä½•ä½“
        const { camera, render, updateFaces } = generateScene(document.getElementById('scene-svg'), faces, true, 3, 35, 4, 0, 0);

        // åˆå§‹æ¸²æŸ“
        render();

        function generatePath(points) {
            const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
            let pathData = `M ${points[0].x} ${points[0].y}`;
            for (let i = 1; i < points.length; i++) {
                const point = points[i];
                pathData += ` L ${point.x} ${point.y}`;
            }
            path.setAttribute("d", pathData);
            return path;
        }

        function hsbToRgb(h, s, b) {
            h = mod(h, 1);
            s = Math.max(0, Math.min(1, s));
            b = Math.max(0, Math.min(1, b));

            // è®¡ç®—è‰²ç›¸çš„ä¸»åŒºåŸŸå’Œå‰©ä½™éƒ¨åˆ†
            const k = (h * 6) % 1;
            const p = b * (1 - s);
            const q = b * (1 - k * s);
            const t = b * (1 - (1 - k) * s);

            // æ ¹æ®è‰²ç›¸åŒºé—´è®¡ç®— RGB
            switch (Math.floor(h * 6)) {
                case 0: return [b, t, p];
                case 1: return [q, b, p]; break;
                case 2: return [p, b, t]; break;
                case 3: return [p, q, b]; break;
                case 4: return [t, p, b]; break;
                case 5: return [b, p, q]; break;
            }
        }

        // ä½¿ç”¨å¤æ‚çš„æ˜ å°„å°†ç‚¹æ˜ å°„åˆ°æ™¶ä½“å¹³é¢æ—è·ç¦»
        function coordinatesToParameters(
            angle,  // 0 ~ 1
            r  // 0 ~ 1
        ) {
            let parameters = hsbToRgb(angle, r, 1);
            parameters[0] **= 0.4;
            parameters[1] **= 0.6;
            parameters[2] **= 0.6;
            parameters[2] *= 1 - 0.072 * Math.max(0, (parameters[1] + parameters[2]) / 2 - parameters[0]);  // é€šè¿‡è°ƒæ•´è¿™ä¸ªå‚æ•°è®©æœ€ä¸‹é¢çš„20é¢ä½“çš„æ‰€æœ‰é¢å‡ä¸ºä¸‰è§’å½¢ï¼Œä½†æ³¨æ„è¿™ä¸ªå‡ ä½•ä½“å§‹ç»ˆä¸ä¼šæ˜¯æ­£äºŒåé¢ä½“
            parameters[0] *= 1 + 0.356 * Math.max(0, (parameters[0] + parameters[1]) / 2 - parameters[2]);  // é€šè¿‡è°ƒæ•´è¿™ä¸ªå‚æ•°è®©å³ä¸Šè§’çš„16é¢ä½“çš„æ‰€æœ‰é¢ä¸ºä¸‰è§’å½¢æˆ–æ­£æ–¹å½¢
            parameters = parameters.map(x => 1 / (x + 1.3));
            return parameters;
        }

        function coordinatesToGeometry(
            angle,  // 0 ~ 1
            r,  // 0 ~ 1
            color
        ) {
            const parameters = coordinatesToParameters(angle, r);

            var { vertices, faces } = getPolygon({  // å„æ™¶é¢æŒ‡æ•°å¯¹åº”çš„é¢åˆ°åŸç‚¹çš„è·ç¦»
                '100': parameters[0],  // ç«‹æ–¹ä½“
                '111': parameters[1],  // å…«é¢ä½“
                '210': parameters[2]  // äº”è§’åäºŒé¢ä½“
            }, color);

            const rawGeometry = { vertices, faces };

            faces = faces.map(face => ({
                points: face.map(i => ({ x: vertices[i][0], y: vertices[i][1], z: vertices[i][2] })),
                color  // æ™¶ä½“é¢œè‰²
            }));
            faces.forEach(compute_face_center);  // è®¡ç®—æ¯ä¸ªé¢çš„ä¸­å¿ƒå¹¶å°†ç»“æœè®°å½•åœ¨é¢æ•°æ®å­—å…¸ä¸­

            return { faces, rawGeometry };
        }

        function addArcText(svg, textContent, options) {
            const {
                cx, cy, radius,
                startAngle = 0, endAngle = 180,
                fontSize = '20', fontFamily, fill = 'black'
            } = options;

            // è®¡ç®—åœ†å¼§è·¯å¾„
            const startRad = (startAngle - 90) * Math.PI / 180;
            const endRad = (endAngle - 90) * Math.PI / 180;

            const startX = cx + radius * Math.cos(startRad);
            const startY = cy + radius * Math.sin(startRad);
            const endX = cx + radius * Math.cos(endRad);
            const endY = cy + radius * Math.sin(endRad);

            const largeArcFlag = endAngle - startAngle <= 180 ? 0 : 1;

            // åˆ›å»ºè·¯å¾„
            const pathId = 'arcPath-' + Math.random().toString(36).substr(2, 9);
            const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            path.setAttribute('id', pathId);
            path.setAttribute('d', `M${startX},${startY} A${radius},${radius} 0 ${largeArcFlag},1 ${endX},${endY}`);
            path.setAttribute('fill', 'none');
            svg.appendChild(path);

            // åˆ›å»ºæ–‡æœ¬
            const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            text.setAttribute('font-size', fontSize);
            text.setAttribute('font-family', fontFamily);
            text.setAttribute('fill', fill);
            text.setAttribute('style', 'user-select: none; pointer-events: none;');

            const textPath = document.createElementNS('http://www.w3.org/2000/svg', 'textPath');
            textPath.setAttribute('href', '#' + pathId);
            textPath.setAttribute('startOffset', '50%');
            textPath.setAttribute('text-anchor', 'middle');
            textPath.textContent = textContent;

            text.appendChild(textPath);
            svg.appendChild(text);

            return { path, text };
        }

        var graphSvgs = [];  // å…³ç³»å›¾ä¸­çš„æ™¶ä½“å°å›¾
        var graphSvgRenders = [];  // å…³ç³»å›¾ä¸­çš„æ™¶ä½“å°å›¾é‡ç»˜å‡½æ•°

        const outerRadiusRelative = 0.7;  // å…³ç³»å›¾å°ºå¯¸ç³»æ•°

        function updateGraph() {  // æ›´æ–°å…³ç³»å›¾
            const svg = document.getElementById('graph');
            svg.innerHTML = '';
            // è·å–SVGçš„å°ºå¯¸å’Œä¸­å¿ƒç‚¹
            const svgRect = svg.getBoundingClientRect();
            const centerX = svgRect.width / 2;
            const centerY = svgRect.height / 2;
            const radius = Math.min(centerX, centerY);  // å›¾åŠå¾„
            const circleRadius1 = 0.19 * radius;
            const circleRadius2 = 0.11 * radius;

            const circles = [];

            // åˆ›å»ºå¤–å±‚12ä¸ªåœ†
            const outerRadius = radius * outerRadiusRelative;
            for (let i = 0; i < 12; i++) {
                const angle = (i / 12) * Math.PI * 2;
                const x = centerX + outerRadius * Math.cos(angle);
                const y = centerY + outerRadius * Math.sin(angle);

                circles.push({
                    x, y,
                    r: i % 4 == 1 ? circleRadius1 : circleRadius2,
                    color: `hsl(${-90 - i / 12 * 360}, ${80}%, ${75}%)`,
                    colorPolygon: `hsla(${-90 - i / 12 * 360}, ${80}%, ${92}%, 80%)`,
                    h: 0.25 + i / 12,
                    s: 1
                });
            }

            // åˆ›å»ºå†…å±‚6ä¸ªåœ†
            const innerRadius = outerRadius * 0.5;
            for (let i = 0; i < 6; i++) {
                const angle = ((i + 0.5) / 6) * Math.PI * 2;
                const x = centerX + innerRadius * Math.cos(angle);
                const y = centerY + innerRadius * Math.sin(angle);

                circles.push({
                    x, y,
                    r: circleRadius2,
                    color: `hsl(${-90 - (i + 0.5) / 6 * 360}, ${50}%, ${82}%)`,
                    colorPolygon: `hsla(${-90 - (i + 0.5) / 6 * 360}, ${50}%, ${95}%, 80%)`,
                    h: 0.25 + (i + 0.5) / 6,
                    s: 0.5
                });
            }

            circles.push({
                x: centerX, y: centerY,
                r: circleRadius2,
                color: `hsl(${0}, ${0}%, ${95}%)`,
                colorPolygon: `hsla(${0}, ${0}%, ${100}%, 80%)`,
                h: 0,
                s: 0
            });

            // è¿æ¥å¤–å±‚12ä¸ªåœ†
            const circle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
            circle.setAttribute("cx", centerX);
            circle.setAttribute("cy", centerY);
            circle.setAttribute("r", radius * outerRadiusRelative); // åŠå¾„
            circle.setAttribute("fill", "none");
            circle.setAttribute("stroke", "black");
            circle.setAttribute("stroke-width", "3");  // çº¿å®½
            svg.appendChild(circle);

            for (let i = 0; i < 6; i++) {
                const points = [circles[18], circles[12 + i]];
                if (i % 2 == 1)
                    points.push(circles[i * 2 + 1]);
                const path = generatePath(points);
                path.setAttribute("stroke", "black");
                path.setAttribute("stroke-width", "3");  // çº¿å®½
                path.setAttribute("fill", "none");
                svg.appendChild(path);

                if (i % 2 == 0) {
                    const path = generatePath([circles[i * 2], circles[12 + i], circles[i * 2 + 2]]);
                    path.setAttribute("stroke", "black");
                    path.setAttribute("stroke-width", "3");  // çº¿å®½
                    path.setAttribute("fill", "none");
                    svg.appendChild(path);
                }
            }

            // æ ‡å‡†å½¢æ€åç§°
            ['Octahedrons {111}', 'Pyritohedrons {210}', 'Cube {100}'].forEach((text, i) => {
                const circle = circles[i * 4 + 1];
                addArcText(svg, text, {
                    cx: circle.x,
                    cy: circle.y,
                    radius: circle.r + radius * 0.025,
                    startAngle: circle.h * 360 - 90,
                    endAngle: circle.h * 360 + 90,
                    fontSize: radius * 0.06,
                    fontFamily: '"Comic Sans MS", cursive',  // ç½‘ä¸Šè¯´ç”¨è¿™ä¸ªå­—ä½“ä¼šè¢«è®¾è®¡ç•Œå˜²ç¬‘ğŸ˜‚
                    fill: 'black'
                });
            });

            circles.forEach(e => {
                // åˆ›å»ºåœ†
                const circle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
                circle.setAttribute("cx", e.x);
                circle.setAttribute("cy", e.y);
                circle.setAttribute("r", e.r); // åŠå¾„
                circle.setAttribute("fill", e.color);
                circle.setAttribute("stroke", "black");
                circle.setAttribute("stroke-width", "1");  // çº¿å®½
                svg.appendChild(circle);
            });

            const constainer = document.querySelectorAll(".square-container")[0];
            const initializing = graphSvgs.length == 0;
            for (let i = 0; i < circles.length; i++) {
                if (initializing) {
                    const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
                    graphSvgs.push(svg);
                }
                graphSvgs[i].style.left = circles[i].x - circles[i].r;
                graphSvgs[i].style.top = circles[i].y - circles[i].r;
                graphSvgs[i].setAttribute("width", circles[i].r * 2);
                graphSvgs[i].setAttribute("height", circles[i].r * 2);
                if (initializing) {
                    constainer.appendChild(graphSvgs[i]);

                    const { faces, rawGeometry } = coordinatesToGeometry(circles[i].h, circles[i].s, circles[i].colorPolygon);

                    // åŠå¾„å‡åŒ€åŒ–
                    let rSum = 0;
                    let vertexNum = 0;
                    faces.forEach(face => face.points.forEach(point => {  // ç»Ÿè®¡æ‰€æœ‰é¡¶ç‚¹åˆ°ä¸­å¿ƒçš„è·ç¦»
                        rSum += vectorLength([point.x, point.y, point.z]);
                        vertexNum++;
                    }));
                    faces.forEach(face => {  // ç»Ÿè®¡æ‰€æœ‰è¾¹ä¸­ç‚¹åˆ°ä¸­å¿ƒçš„è·ç¦»
                        for (let i = 0; i < face.points.length; i++) {
                            const a = face.points[i];
                            const b = face.points[(i + 1) % face.points.length];
                            rSum += vectorLength([a.x + b.x, a.y + b.y, a.z + b.z]) / 2;
                            vertexNum++;
                        }
                    });
                    const rMean = rSum / vertexNum;
                    faces.forEach(face => face.points.forEach(point => {
                        point.x /= rMean;
                        point.y /= rMean;
                        point.z /= rMean;
                    }));

                    const { camera, render, updateFaces } = generateScene(
                        graphSvgs[i],
                        faces,
                        false,  // ç¦ç”¨é¼ æ ‡äº¤äº’
                        6,  // æ‘„åƒæœºè·ç¦»ã€‚æ­£8é¢ä½“æ˜¾ç¤ºå‡ºæ¥ä¼šåæ·¡æ‰‹åŠ¨æŠŠæ‘„åƒæœºè®¾çš„ç¨å¾®è¿œäº›
                        25,  // è§†è§’
                        1.5,  // çº¿å®½
                        50,  // åˆå§‹æ‘„åƒæœºè§’åº¦ phi
                        -30  // åˆå§‹æ‘„åƒæœºè§’åº¦ theta
                    );
                    graphSvgRenders.push(render);
                    render();  // åˆå§‹æ¸²æŸ“
                }
                else
                    graphSvgRenders[i]();
            }

        };
    </script>

    <!-- æ—‹è½¬æŒ‰é’® -->
    <script>
        // è‡ªè½¬æ§åˆ¶
        let isRotating = true;
        let lastTime = 0;
        let rotationSpeed = 0.00025; // æ—‹è½¬é€Ÿåº¦

        function animate(time) {
            if (!lastTime) lastTime = time;
            const deltaTime = time - lastTime;
            lastTime = time;

            if (isRotating) {
                camera.phi += rotationSpeed * deltaTime;
                render();
            }

            requestAnimationFrame(animate);
        }

        requestAnimationFrame(animate);

        // æŒ‰é’®æ§åˆ¶
        const rotateButton = document.getElementById('rotate-button');
        rotateButton.addEventListener('click', function () {
            isRotating = !isRotating;
            rotateButton.classList.toggle('pressed');
        });
    </script>

    <!-- å›¾é’‰ -->
    <script>
        const pin = document.getElementById('pin');
        var pinLocationRelative = { x: 0, y: 0 };

        function updatePinLocation() {
            const svg = document.getElementById('graph');
            const svgRect = svg.getBoundingClientRect();
            const centerX = svgRect.width / 2;
            const centerY = svgRect.height / 2;
            const radius = Math.min(centerX, centerY);  // å›¾åŠå¾„

            const x = pinLocationRelative.x * radius * outerRadiusRelative + svgRect.left + centerX;
            const y = pinLocationRelative.y * radius * outerRadiusRelative + svgRect.top + centerY;
            pin.style.left = `${x}px`;
            pin.style.top = `${y}px`;
        }

        function movePin(e) {
            e.preventDefault();

            let x, y;

            if (e.type === 'touchstart') {
                x = e.touches[0].clientX;
                y = e.touches[0].clientY;
            } else {
                x = e.clientX;
                y = e.clientY;
            }

            const svg = document.getElementById('graph');
            const svgRect = svg.getBoundingClientRect();
            const centerX = svgRect.width / 2;
            const centerY = svgRect.height / 2;
            const radius = Math.min(centerX, centerY);  // å›¾åŠå¾„
            let xRelative = (x - svgRect.left - centerX);
            let yRelative = (y - svgRect.top - centerY);
            let rRelative = (xRelative ** 2 + yRelative ** 2) ** 0.5;
            if (rRelative > radius * outerRadiusRelative) {
                xRelative *= radius * outerRadiusRelative / rRelative;
                yRelative *= radius * outerRadiusRelative / rRelative;
                rRelative = radius * outerRadiusRelative;
                x = xRelative + svgRect.left + centerX;
                y = yRelative + svgRect.top + centerY;
            }
            xRelative /= radius * outerRadiusRelative;
            yRelative /= radius * outerRadiusRelative;
            rRelative /= radius * outerRadiusRelative;;
            pinLocationRelative.x = xRelative;
            pinLocationRelative.y = yRelative;

            pin.style.left = `${x}px`;
            pin.style.top = `${y}px`;

            const angle = Math.atan2(yRelative, xRelative);
            const { faces, rawGeometry } = coordinatesToGeometry(angle / Math.PI / 2 + 0.25, rRelative, 'rgba(230, 220, 120, 0.8)');
            updateFaces(faces);
            render();
        }

        const graphPanel = document.getElementById('graph-panel');
        var isDragging = false;
        // ç‚¹å‡»æˆ–è§¦æ‘¸æ—¶ç§»åŠ¨å¤§å¤´é’ˆ
        graphPanel.addEventListener('pointerdown', function (e) {
            movePin(e);
            isDragging = true;
        });
        document.addEventListener('pointermove', function (e) {
            if (isDragging) {
                movePin(e);
            }
        });
        document.addEventListener('pointerup', function (e) {
            isDragging = false;
        });
        graphPanel.addEventListener('touchstart', movePin);
        // ç§»åŠ¨è®¾å¤‡æ”¯æŒè§¦æ‘¸ç§»åŠ¨
        graphPanel.addEventListener('touchmove', movePin);
    </script>

    <!-- ä¿å­˜ä¸º OBJ æ–‡ä»¶ -->
    <script>
        function generateOBJ(vertices, faces) {
            let objContent = "";

            // å†™å…¥é¡¶ç‚¹
            vertices.forEach(v => {
                objContent += `v ${v[0]} ${v[1]} ${v[2]}\n`;
            });

            // å†™å…¥é¢ï¼ˆæ”¯æŒä»»æ„è¾¹æ•°çš„å¤šè¾¹å½¢ï¼‰ï¼ˆæ³¨æ„é¡¶ç‚¹ç´¢å¼•æ˜¯ä»1å¼€å§‹çš„ï¼‰
            faces.forEach(f => {
                objContent += `f ${f.map(i => i + 1).join(" ")}\n`;
            });

            return objContent;
        }

        function saveOBJToFile(objContent, filename) {
            // åˆ›å»ºBlobå¯¹è±¡
            const blob = new Blob([objContent], { type: 'text/plain' });

            // åˆ›å»ºä¸‹è½½é“¾æ¥
            const link = document.createElement('a');
            link.href = URL.createObjectURL(blob);
            link.download = filename;

            // è§¦å‘ç‚¹å‡»ä¸‹è½½
            document.body.appendChild(link);
            link.click();

            // æ¸…ç†
            setTimeout(() => {
                document.body.removeChild(link);
                URL.revokeObjectURL(link.href);
            }, 100);
        }

        // æŒ‰é’®æ§åˆ¶
        const saveButton = document.getElementById('save-button');
        saveButton.addEventListener('click', function () {
            const rRelative = (pinLocationRelative.x ** 2 + pinLocationRelative.y ** 2) ** 0.5;;
            const angle = Math.atan2(pinLocationRelative.y, pinLocationRelative.x);
            const { faces, rawGeometry } = coordinatesToGeometry(angle / Math.PI / 2 + 0.25, rRelative, '');
            const objString = generateOBJ(rawGeometry.vertices, rawGeometry.faces);
            saveOBJToFile(objString, 'pyrite_crystal.obj');  // ä¸‹è½½æ–‡ä»¶
        });

    </script>

    <!-- å¸ƒå±€éƒ¨åˆ†ä»£ç  -->
    <script>
        function updateLayout() {
            const container = document.querySelector('.split-container');
            const isPortrait = window.innerHeight > window.innerWidth;

            if (isPortrait) {
                container.classList.add('vertical');
            } else {
                container.classList.remove('vertical');
            }

            render();
            updateGraph();
            updatePinLocation();
        }

        // åˆå§‹åŠ è½½æ—¶æ›´æ–°å¸ƒå±€
        updateLayout();

        // çª—å£å¤§å°æ”¹å˜æ—¶æ›´æ–°å¸ƒå±€
        window.addEventListener('resize', updateLayout);
    </script>
</body>

</html>