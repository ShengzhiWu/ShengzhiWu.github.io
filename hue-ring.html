<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hue Ring</title>
    <style>
        body {
            margin: 0;
            overflow: hidden; 
            background-color: #575757;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
        }

        #image-container {
            position: absolute;
            max-width: 100%;
            max-height: 100%;
            box-shadow: 0 0 50px rgba(0, 0, 0, 0.4);
            z-index: 1;
        }

        #three-canvas {
            display: block;
            object-fit: contain;
        }
        
        .hue-ring-container {
            position: absolute;
            top: 30px;
            right: 30px;
            width: 400px;
            height: 400px;
            z-index: 2;
            opacity: 0;  /* 加载图片之后才显示 */
        }
        
        #hue-ring {
            position: absolute;
            background: rgb(255, 255, 255, 0.3);
            border-radius: 50%;
            backdrop-filter: blur(10px);
            /* box-shadow: 0 0 20px rgba(0, 0, 0, 0.1); */
        }
        
        svg {
            position: absolute;
            width: 100%;
            height: 100%;
        }
        
        .control-point {
            fill: white;
            stroke: rgba(0, 0, 0, 0.1);
            stroke-width: 1;
            cursor: move;
        }
        
        .control-text {
            font-size: 10px;
            text-anchor: middle;
            dominant-baseline: middle;
            pointer-events: none;
            user-select: none;
        }
        
        .ray {
            stroke-linecap: round;
        }
        
        .ray-end {
            pointer-events: none;
        }

        button {
            /* 定位在右下角 */
            position: fixed;
            right: 20px;
            bottom: 20px;
            z-index: 2;

            /* 磨砂玻璃效果 */
            background: rgb(255, 255, 255, 0.3);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border: none;
            border-radius: 12px; /* 圆角 */

            /* 文字样式 */
            color: white;
            font-family: 'Arial', sans-serif;
            font-size: 16px;
            font-weight: 500;
            padding: 10px 24px;
            cursor: pointer;
        }

        button:hover {
            background: rgba(255, 255, 255, 0.4);
        }

        button:active {
            background: rgba(255, 255, 255, 0.25);
        }

        /* 拖拽时的页面遮罩层 */
        .drag-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(255, 255, 255, 0.3);
            z-index: 3;
            display: none;
            justify-content: center;
            pointer-events: none;  /* 防止遮罩层拦截鼠标事件 */
        }

        #drop-zone {
            width: 330px;
            height: 330px;
            position: relative;
            display: flex;
            flex-direction: column;
            /* justify-content: center; */
            align-items: center;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15);
            background: rgba(255, 255, 255, 0.2);
            border-radius: 15px;
            pointer-events: none;
        }

        /* Corner markers */
        #drop-zone::before, #drop-zone::after,
        #drop-zone .corner-marker {
            content: '';
            position: absolute;
            width: 20px;
            height: 20px;
            border: 2px solid white;
        }

        #drop-zone::before { /* Top-left */
            top: 10px;
            left: 10px;
            border-right: none;
            border-bottom: none;
        }

        #drop-zone::after { /* Bottom-right */
            bottom: 10px;
            right: 10px;
            border-left: none;
            border-top: none;
        }

        #drop-zone .corner-marker.top-right { /* Top-right */
            top: 10px;
            right: 10px;
            border-left: none;
            border-bottom: none;
        }

        #drop-zone .corner-marker.bottom-left { /* Bottom-left */
            bottom: 10px;
            left: 10px;
            border-right: none;
            border-top: none;
        }

        #drop-content {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
        }

        #drop-zone svg {
            top: 95px;
            width: 80px;
            height: 80px;
            filter: drop-shadow(0 2px 4px rgba(0, 0, 0, 0.2));
        }

        #drop-zone p {
            color: white;
            text-shadow: 0 1px 3px rgba(0, 0, 0, 0.3);
            font-size: 20px;
            margin-top: 195px;
            text-align: center;
        }

        /* Hover/active states */
        #drop-zone.drag-over {
            background: rgba(255, 255, 255, 0.3);
        }
    </style>
</head>
<body>
    <div class="hue-ring-container">
        <!-- Canvas 绘制色相环 -->
        <canvas id="hue-ring"></canvas>
        
        <!-- SVG 绘制其他元素 -->
        <svg id="svgElements">
            <defs>
                <!-- 平滑曲线的渐变色 -->
                <linearGradient id="curveGradient" x1="0%" y1="0%" x2="100%" y2="100%">
                    <stop offset="0%" stop-color="hsl(0, 100%, 50%)"/>
                    <stop offset="8.33%" stop-color="hsl(30, 100%, 50%)"/>
                    <stop offset="16.66%" stop-color="hsl(60, 100%, 50%)"/>
                    <stop offset="25%" stop-color="hsl(90, 100%, 50%)"/>
                    <stop offset="33.33%" stop-color="hsl(120, 100%, 50%)"/>
                    <stop offset="41.66%" stop-color="hsl(150, 100%, 50%)"/>
                    <stop offset="50%" stop-color="hsl(180, 100%, 50%)"/>
                    <stop offset="58.33%" stop-color="hsl(210, 100%, 50%)"/>
                    <stop offset="66.66%" stop-color="hsl(240, 100%, 50%)"/>
                    <stop offset="75%" stop-color="hsl(270, 100%, 50%)"/>
                    <stop offset="83.33%" stop-color="hsl(300, 100%, 50%)"/>
                    <stop offset="91.66%" stop-color="hsl(330, 100%, 50%)"/>
                    <stop offset="100%" stop-color="hsl(360, 100%, 50%)"/>
                </linearGradient>
            </defs>
            
            <!-- 平滑曲线 -->
            <path id="curvePath" fill="none" stroke="rgba(255, 255, 255, 0.5)"/>
            
            <!-- 射线 -->
            <g id="rays"></g>
            
            <!-- 控制点 -->
            <g id="controlPoints"></g>
        </svg>
    </div>

    <script>
        var material;
        var saveButtonOnClick = undefined;
    </script>

    <script>
        const hueRingContainer = document.querySelector('.hue-ring-container');
        const radius = Math.min(hueRingContainer.offsetWidth, hueRingContainer.offsetHeight) / 2;

        // 主配置
        const config = {
            radius: radius,
            center: { x: radius, y: radius },
            hueRingRadiusMin: radius / 4,
            hueRingRadiusMax: radius * 0.7,
            controlPointsCount: 12,
            controlPointRadius: radius / 30,
            kernelRadius: 2,
            histogramBinCount: 150,  // 直方图柱子数量
            histogramRadiusMin: radius * 23 / 30,
            histogramRadiusMax: radius * 14 / 15,
            rayThickness: radius / 80,
            curveThickness: radius / 40
        };
        
        // 状态
        let state = {
            controlPoints: [],
            raysLength: new Array(config.histogramBinCount).fill(0),
            isDragging: false,
            draggedPointIndex: -1
        };
        
        // 获取Canvas和SVG元素
        const hueRingCanvas = document.getElementById('hue-ring');
        hueRingCanvas.width = config.radius * 2;
        hueRingCanvas.height = config.radius * 2;
        const hueRingCtx = hueRingCanvas.getContext('2d');
        
        const svg = document.getElementById('svgElements');
        const curvePath = document.getElementById('curvePath');
        curvePath.style.strokeWidth = Math.max(1, config.curveThickness);
        const raysGroup = document.getElementById('rays');
        const controlPointsGroup = document.getElementById('controlPoints');
        
        // 初始化
        function init() {
            createControlPoints();
            // initializeRayLengths();
            drawHueRing();
            updateCurve();
            drawRays();
            drawControlPoints();
            
            setupEventListeners();
        }
        
        // 创建控制点
        function createControlPoints() {
            state.controlPoints = [];
            for (let i = 0; i < config.controlPointsCount; i++) {
                const angle = i / config.controlPointsCount * Math.PI * 2;
                const radius = (config.hueRingRadiusMax + config.hueRingRadiusMin) / 2;
                const x = config.center.x + radius * Math.cos(angle);
                const y = config.center.y + radius * Math.sin(angle);
                const color = `hsl(${i / config.controlPointsCount * 360}, 100%, 50%)`;
                state.controlPoints.push({ x, y, angle, originalAngle: angle, radius, color });
            }
        }
        
        // 初始化射线长度
        // function initializeRayLengths() {
        //     for (let i = 0; i < config.histogramBinCount; i++) {
        //         const t = i / config.histogramBinCount;
        //         state.raysLength[i] = 0;
        //     }
        // }
        
        // 绘制色相环 (使用Canvas)
        function drawHueRing() {
            hueRingCtx.clearRect(0, 0, hueRingCanvas.width, hueRingCanvas.height);
            
            // 1. 首先绘制完整的色相环
            const gradient = hueRingCtx.createConicGradient(0, config.center.x, config.center.y);
            for (let i = 0; i <= 360; i += 60) {
                gradient.addColorStop(i / 360, `hsl(${i}, 100%, 50%)`);
            }
            
            hueRingCtx.beginPath();
            hueRingCtx.arc(config.center.x, config.center.y, config.hueRingRadiusMax, 0, Math.PI * 2);
            hueRingCtx.fillStyle = gradient;
            hueRingCtx.fill();
            
            // 2. 然后叠加一个白色到透明的径向渐变
            const radialGradient = hueRingCtx.createRadialGradient(
                config.center.x, config.center.y, config.hueRingRadiusMin,
                config.center.x, config.center.y, config.hueRingRadiusMax
            );
            radialGradient.addColorStop(0, 'rgba(128, 128, 128, 1)');  // 中心饱和度最低
            radialGradient.addColorStop(0.5, 'rgba(128, 128, 128, 0.6)');
            radialGradient.addColorStop(1, 'rgba(128, 128, 128, 0)'); // 边缘饱和度最高
            
            hueRingCtx.beginPath();
            hueRingCtx.arc(config.center.x, config.center.y, config.hueRingRadiusMax, 0, Math.PI * 2);
            hueRingCtx.fillStyle = radialGradient;
            hueRingCtx.fill();
            
            // 3. 添加中心白色实心圆（确保中心是完全白色）
            hueRingCtx.beginPath();
            hueRingCtx.arc(config.center.x, config.center.y, config.hueRingRadiusMin, 0, Math.PI * 2);
            hueRingCtx.fillStyle = 'white';
            hueRingCtx.fill();
        }
        
        // 更新平滑曲线 (使用SVG)
        function updateCurve() {
            // 采样点数 - 可以根据需要调整
            const sampleCount = 200;
            let pathData = '';
            
            // 获取第一个点并移动到该位置
            const firstPoint = getPointOnCurve(0);
            pathData = `M ${firstPoint.x} ${firstPoint.y}`;
            
            // 采样曲线上的点
            for (let i = 1; i <= sampleCount; i++) {
                const t = i / sampleCount;
                const point = getPointOnCurve(t);
                pathData += ` L ${point.x} ${point.y}`;
            }
            
            // 闭合路径
            pathData += ' Z';
            
            curvePath.setAttribute('d', pathData);
        }

        function vectorAdd(u, v) {
            return {x: u.x + v.x, y: u.y + v.y};
        }

        function vectorSub(u, v) {
            return {x: u.x - v.x, y: u.y - v.y};
        }

        function scaleVector(k, v) {
            return {x: v.x * k, y: v.y * k};
        }

        function vectorNorm(v) {
            return (v.x ** 2 + v.y ** 2) ** 0.5;
        }

        function normalize(v) {
            return scaleVector(1 / vectorNorm(v), v)
        }
        
        // 绘制射线 (使用SVG)
        function drawRays() {
            // 清空现有射线
            while (raysGroup.firstChild) {
                raysGroup.removeChild(raysGroup.firstChild);
            }
            
            for (let i = 0; i < config.histogramBinCount; i++) {                
                // 计算曲线上的点
                const t = i / config.histogramBinCount;
                const normal = normalize(vectorSub(getPointOnCurve(t), config.center));

                const rayCenter = vectorAdd(scaleVector((config.histogramRadiusMin + config.histogramRadiusMax) / 2, normal), config.center);

                // 射线长度
                const maxRayLength = config.histogramRadiusMax - config.histogramRadiusMin;
                const length = state.raysLength[i] * maxRayLength;
                
                // 射线终点
                const start = vectorAdd(rayCenter, scaleVector(-length / 2, normal));
                const end = vectorAdd(rayCenter, scaleVector(length / 2, normal));
                
                // 创建射线
                const ray = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                ray.setAttribute('x1', start.x);
                ray.setAttribute('y1', start.y);
                ray.setAttribute('x2', end.x);
                ray.setAttribute('y2', end.y);
                ray.setAttribute('stroke', `hsl(${t * 360}, 80%, 50%)`);
                ray.setAttribute('stroke-width', config.rayThickness);
                ray.setAttribute('class', 'ray');
                raysGroup.appendChild(ray);
            }
        }

        function getClosestAngle(angle, reference) {
            while (angle < reference - Math.PI)
                angle += Math.PI * 2;
            while (angle > reference + Math.PI)
                angle -= Math.PI * 2;
            return angle;
        }

        function kernel(x, power) {  // 核函数。power决定了局域化程度
            x = Math.abs(x);
            if (x >= config.kernelRadius)
                return 0;
            return (1 - (x / config.kernelRadius) ** 2) ** power;
        }
        
        // 获取曲线上的点
        function getPointOnCurve(t) {
            while (t < 0)
                t += 1;
            t %= 1;
            t *= state.controlPoints.length;
            const i = Math.floor(t);

            let sum1 = 0;
            let sum2 = 0;
            const result = {angle: 0, radius: 0};
            for (let j = i - config.kernelRadius + 1; j <= i + config.kernelRadius; j ++) {
                const weight1 = kernel(j - t, 3);  // 控制点对角度的影响更平滑，所以 power 较低
                const weight2 = kernel(j - t, 7);  // 控制点对半径的影响更局域化，所以 power 较高
                let k = j;
                while (k < 0)
                    k += state.controlPoints.length;
                k %= state.controlPoints.length;

                let angle = state.controlPoints[k].angle;
                let originalAngle = state.controlPoints[k].originalAngle;
                const reference = state.controlPoints[i].originalAngle;
                while (originalAngle < reference - Math.PI){
                    originalAngle += Math.PI * 2;
                    angle += Math.PI * 2;
                }
                while (originalAngle > reference + Math.PI) {
                    originalAngle -= Math.PI * 2;
                    angle -= Math.PI * 2;
                }

                result.angle += weight1 * angle;
                result.radius += weight2 * state.controlPoints[k].radius;
                sum1 += weight1;
                sum2 += weight2;
            }
            result.angle /= sum1;
            result.radius /= sum2;

            result.x = config.center.x + result.radius * Math.cos(result.angle),
            result.y = config.center.y + result.radius * Math.sin(result.angle)
            
            return result;
        }
        
        // 绘制控制点 (使用SVG)
        function drawControlPoints() {
            // 清空现有控制点
            while (controlPointsGroup.firstChild) {
                controlPointsGroup.removeChild(controlPointsGroup.firstChild);
            }
            
            state.controlPoints.forEach((point, index) => {
                // 创建控制点圆形
                const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                circle.setAttribute('cx', point.x);
                circle.setAttribute('cy', point.y);
                circle.setAttribute('r', config.controlPointRadius);
                circle.setAttribute('class', 'control-point');
                circle.setAttribute('data-index', index);
                controlPointsGroup.appendChild(circle);
                
                // 创建控制点圆形
                const circle2 = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                circle2.setAttribute('cx', point.x);
                circle2.setAttribute('cy', point.y);
                circle2.setAttribute('r', config.controlPointRadius * 0.5);
                circle2.setAttribute('fill', point.color);
                circle2.setAttribute('pointer-events', 'none');
                controlPointsGroup.appendChild(circle2);
            });
        }
        
        // 事件监听
        function setupEventListeners() {
            // 控制点拖动
            svg.addEventListener('mousedown', (e) => {
                if (e.target.classList.contains('control-point')) {
                    state.isDragging = true;
                    state.draggedPointIndex = parseInt(e.target.getAttribute('data-index'));
                }
            });
            
            svg.addEventListener('mousemove', (e) => {
                if (state.isDragging) {
                    const pt = svg.createSVGPoint();
                    pt.x = e.clientX;
                    pt.y = e.clientY;
                    const cursorPt = pt.matrixTransform(svg.getScreenCTM().inverse());
                    
                    // 计算角度和半径
                    const dx = cursorPt.x - config.center.x;
                    const dy = cursorPt.y - config.center.y;
                    const angle = getClosestAngle(Math.atan2(dy, dx), state.controlPoints[state.draggedPointIndex].angle);  // 让角度连续变化
                    let radius = Math.sqrt(dx * dx + dy * dy);
                    
                    // 限制半径范围
                    radius = Math.max(config.hueRingRadiusMin, radius);
                    radius = Math.min(config.hueRingRadiusMax, radius);
                    
                    // 更新控制点
                    state.controlPoints[state.draggedPointIndex].x = config.center.x + radius * Math.cos(angle)
                    state.controlPoints[state.draggedPointIndex].y = config.center.y + radius * Math.sin(angle)
                    state.controlPoints[state.draggedPointIndex].angle = angle
                    state.controlPoints[state.draggedPointIndex].radius = radius

                    material.uniforms.controlPointsAngles.value[state.draggedPointIndex] = angle;
                    material.uniforms.controlPointsRadii.value[state.draggedPointIndex] = (radius - config.hueRingRadiusMin) / (config.hueRingRadiusMax - config.hueRingRadiusMin);  // 归一化到 0 ~ 1
                    
                    // 更新色相环
                    updateCurve();
                    drawRays();
                    drawControlPoints();

                    // 更新预览图
                    render();
                }
            });
            
            svg.addEventListener('mouseup', () => {
                state.isDragging = false;
                state.draggedPointIndex = -1;
            });
            
            svg.addEventListener('mouseleave', () => {
                state.isDragging = false;
                state.draggedPointIndex = -1;
            });
        }
        
        // 初始化
        init();
    </script>

    <div id="image-container"></div>

    <button id="save-button">Save</button>
    
    <!-- Three.js从CDN加载 -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.min.js"></script>
    
    <script>
        function rgbToHue(r, g, b) {  // Hue: 0 ~ 1
            r /= 255, g /= 255, b /= 255;
            const max = Math.max(r, g, b), min = Math.min(r, g, b);
            let h = 0;
            
            if (max !== min) {
                const d = max - min;
                switch (max) {
                    case r: h = (g - b) / d + (g < b ? 6 : 0); break;
                    case g: h = (b - r) / d + 2; break;
                    case b: h = (r - g) / d + 4; break;
                }
                h *= 60;
            }
            
            return h / 360;
        }

        function getHueDistribution(image, binCount) {  // 计算色相分布
            // 创建临时canvas分析纹理
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            
            // 设置canvas尺寸与图像相同
            canvas.width = image.width;
            canvas.height = image.height;
            
            // 将图像绘制到canvas
            ctx.drawImage(image, 0, 0);
            
            // 获取像素数据
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data; // RGBA数组
            
            // 初始化色相直方图
            const hueHistogram = new Float32Array(binCount);
            let totalPixels = 0;
            
            // 遍历所有像素
            for (let i = 0; i < data.length; i += 4) {
                const r = data[i];
                const g = data[i + 1];
                const b = data[i + 2];
                
                // 将RGB转换为HSV/HSL色相 (0-360)
                const hue = rgbToHue(r, g, b);
                
                // 统计到直方图
                const hueIndex = Math.round(hue * binCount);
                hueHistogram[hueIndex] ++;
                totalPixels ++;
            }

            return hueHistogram;
        }

        // 初始化容器和渲染器
        const canvasContainer = document.getElementById('image-container');
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setClearColor(0x808080);
        canvasContainer.appendChild(renderer.domElement);
        renderer.domElement.id = 'three-canvas';
        renderer.domElement.style.display = 'none';
        
        // 初始化场景和相机
        const scene = new THREE.Scene();
        const camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0.1, 10);
        camera.position.z = 1;

        function render() {
            renderer.render(scene, camera);
        }
        
        // 存储图片宽高比
        let imgAspect = 1; // 默认1:1
        
        // 加载图片
        // const textureLoader = new THREE.TextureLoader();
        // textureLoader.load('test_images/1364px-Van_Gogh_-_Starry_Night_-_Google_Art_Project.jpg',
        //     ,
        //     undefined,
        //     (error) => {
        //         console.error('图片加载失败:', error);
        //         const errorDiv = document.createElement('div');
        //         errorDiv.textContent = '图片加载失败，请检查路径和文件名';
        //         errorDiv.style.cssText = 'position:absolute; top:50%; left:50%; transform:translate(-50%,-50%); color:red;';
        //         document.body.appendChild(errorDiv);
        //     }
        // );
        
        // 自适应尺寸函数
        function updateSize() {
            const width = window.innerWidth;
            const height = window.innerHeight;
            
            let canvasWidth, canvasHeight;
            
            if (width / height > imgAspect) {
                // 窗口比图片宽，高度为100%，宽度按比例
                canvasHeight = height;
                canvasWidth = height * imgAspect;
            } else {
                // 窗口比图片高，宽度为100%，高度按比例
                canvasWidth = width;
                canvasHeight = width / imgAspect;
            }
            
            // 应用尺寸到Canvas
            renderer.setSize(canvasWidth, canvasHeight, false); // 第三个参数false防止CSS覆盖
            renderer.domElement.style.width = `${canvasWidth}px`;
            renderer.domElement.style.height = `${canvasHeight}px`;
        }
        
        // 窗口大小变化监听
        window.addEventListener('resize', () => {
            updateSize();
            render();
        });

        function saveOriginalResImage(renderer, scene, camera, originalTexture) {  // 保存原分辨率结果
            // 获取原始纹理的尺寸（假设 texture 是 THREE.Texture 实例）
            const width = originalTexture.image.width;
            const height = originalTexture.image.height;

            // 保存当前渲染器尺寸（用于恢复）
            const originalSize = {
                width: renderer.domElement.width,
                height: renderer.domElement.height,
            };

            // 临时调整渲染器尺寸以匹配原始纹理
            renderer.setSize(width, height, false); // false 表示不更新 CSS 样式

            // 重新渲染（确保场景和相机正确）
            renderer.render(scene, camera);

            // 获取 Canvas 数据并触发下载
            const canvas = renderer.domElement;
            const link = document.createElement('a');
            link.href = canvas.toDataURL('image/png');
            link.download = 'high-res-image.png'; // 可自定义文件名
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);

            // 恢复原始渲染器尺寸并重新渲染
            renderer.setSize(originalSize.width, originalSize.height, false);
            render();
        }
    </script>

    <!-- 拖拽时的遮罩层 -->
    <div class="drag-overlay"></div>

    <!--  提示用户拖动图片并释放到这里 -->
    <div id="drop-zone">
        <div class="corner-marker top-right"></div>
        <div class="corner-marker bottom-left"></div>
        <div id="drop-content">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect>
                <circle cx="8.5" cy="8.5" r="1.5"></circle>
                <polyline points="21 15 16 10 5 21"></polyline>
            </svg>
            <p>Drag & Drop an Image Here</p>
        </div>
    </div>

    <script>
        const body = document.body;
        const dragOverlay = document.querySelector('.drag-overlay');

        body.addEventListener('dragover', (e) => {
            e.preventDefault();
            e.stopPropagation();
            dragOverlay.style.display = 'flex';
        });

        // 拖拽离开或取消时隐藏遮罩层
        const hideDragOverlay = () => {
            dragOverlay.style.display = 'none';
        };

        body.addEventListener('dragleave', hideDragOverlay);
        body.addEventListener('drop', (e) => {
            e.preventDefault();
            hideDragOverlay();
            
            const files = e.dataTransfer.files;
            if (files.length > 0 && files[0].type.match('image.*')) {
                loadImage(files[0]);
            }
        });

        // Prevent default drag behaviors
        [body].forEach(el => {
            el.addEventListener('dragover', e => {
                e.preventDefault();
                e.stopPropagation();
            });

            el.addEventListener('dragleave', e => {
                e.preventDefault();
                e.stopPropagation();
            });

            el.addEventListener('drop', e => {
                e.preventDefault();
                e.stopPropagation();
                
                const files = e.dataTransfer.files;
                if (files.length > 0) {
                    const file = files[0];
                    if (file.type.match('image.*')) {
                        loadImage(file);
                    }
                }
            });
        });

        function loadImage(file) {
            const reader = new FileReader();
            reader.onload = function(e) {
                const textureLoader = new THREE.TextureLoader();
                textureLoader.load(
                    e.target.result,
                    (texture) => {
                        const hueHistogram = getHueDistribution(texture.image, config.histogramBinCount);

                        // 归一化
                        const maxValue = hueHistogram.reduce((a, b) => Math.max(a, b));
                        state.raysLength = hueHistogram.map(e => e / maxValue);
                        drawRays();  // 更新色相直方图

                        document.getElementById('drop-zone').style.display = 'none';
                        renderer.domElement.style.display = 'block';
                        hueRingContainer.style.opacity = 1;
                        
                        // 获取图片实际尺寸并计算宽高比
                        imgAspect = texture.image.width / texture.image.height;
                        
                        // 创建材质
                        material = new THREE.ShaderMaterial({
                            uniforms: {
                                img: { value: texture },
                                kernelRadius: { value: 2 },
                                controlPointsCount: { value: config.controlPointsCount },
                                center: { value: new THREE.Vector2(config.center.x, config.center.y) },
                                controlPointsAngles: { value: new Float32Array(state.controlPoints.map(e => e.angle)) },
                                controlPointsOriginalAngles: { value: new Float32Array(state.controlPoints.map(e => e.originalAngle)) },
                                controlPointsRadii: { value: new Float32Array(state.controlPoints.map(e => (e.radius - config.hueRingRadiusMin) / (config.hueRingRadiusMax - config.hueRingRadiusMin))) }
                            },
                            vertexShader: `
                                varying vec2 vUv;
                                void main() {
                                    vUv = uv;
                                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                                }
                            `,
                            fragmentShader: `
                                uniform sampler2D img;
                                uniform int kernelRadius;
                                uniform int controlPointsCount;  // 控制点数量
                                uniform vec2 center;             // 中心点坐标
                                uniform float controlPointsAngles[${config.controlPointsCount}];   // 控制点角度数组
                                uniform float controlPointsOriginalAngles[${config.controlPointsCount}]; // 控制点原始角度数组
                                uniform float controlPointsRadii[${config.controlPointsCount}];    // 控制点半径数组
                                varying vec2 vUv;

                                // 将RGB颜色（范围0.0-1.0）转换为HSL颜色（范围H:0.0-1.0, S:0.0-1.0, L:0.0-1.0）
                                vec3 rgbToHsl(vec3 rgb) {
                                    float maxVal = max(max(rgb.r, rgb.g), rgb.b);
                                    float minVal = min(min(rgb.r, rgb.g), rgb.b);
                                    float h = 0.0, s = 0.0, l = (maxVal + minVal) / 2.0;
                                    
                                    if (maxVal != minVal) {
                                        float d = maxVal - minVal;
                                        s = l > 0.5 ? d / (2.0 - maxVal - minVal) : d / (maxVal + minVal);
                                        
                                        if (maxVal == rgb.r) {
                                            h = (rgb.g - rgb.b) / d + (rgb.g < rgb.b ? 6.0 : 0.0);
                                        } else if (maxVal == rgb.g) {
                                            h = (rgb.b - rgb.r) / d + 2.0;
                                        } else {
                                            h = (rgb.r - rgb.g) / d + 4.0;
                                        }
                                        
                                        h /= 6.0;
                                    }
                                    
                                    return vec3(h, s, l);
                                }

                                // 辅助函数：计算色相分量
                                float hueToRgb(float p, float q, float t) {
                                    if (t < 0.0) t += 1.0;
                                    if (t > 1.0) t -= 1.0;
                                    if (t < 1.0/6.0) return p + (q - p) * 6.0 * t;
                                    if (t < 1.0/2.0) return q;
                                    if (t < 2.0/3.0) return p + (q - p) * (2.0/3.0 - t) * 6.0;
                                    return p;
                                }

                                // 将HSL颜色（范围H:0.0-1.0, S:0.0-1.0, L:0.0-1.0）转换为RGB颜色（范围0.0-1.0）
                                vec3 hslToRgb(vec3 hsl) {
                                    float h = hsl.x;
                                    float s = hsl.y;
                                    float l = hsl.z;
                                    
                                    float r, g, b;
                                    
                                    if (s == 0.0) {
                                        r = g = b = l; // 无饱和度，就是灰度
                                    } else {
                                        float q = l < 0.5 ? l * (1.0 + s) : l + s - l * s;
                                        float p = 2.0 * l - q;
                                        
                                        r = hueToRgb(p, q, h + 1.0/3.0);
                                        g = hueToRgb(p, q, h);
                                        b = hueToRgb(p, q, h - 1.0/3.0);
                                    }
                                    
                                    return vec3(r, g, b);
                                }

                                // 核函数。power决定了局域化程度
                                float kernel(float x, float power) {
                                    x = abs(x);
                                    if (x >= float(kernelRadius))
                                        return 0.0;
                                    float ratio = x / float(kernelRadius);
                                    return pow(1.0 - ratio * ratio, power);
                                }

                                // 获取曲线上的点
                                vec2 getPointOnCurve(float t) {
                                    // 规范化t值到[0,1)范围
                                    while (t < 0.0) t += 1.0;
                                    t = mod(t, 1.0);
                                    t *= float(controlPointsCount);
                                    int i = int(floor(t));
                                    
                                    float sum1 = 0.0;
                                    float sum2 = 0.0;
                                    float resultAngle = 0.0;
                                    float resultRadius = 0.0;
                                    
                                    // 获取参考角度
                                    float reference = controlPointsOriginalAngles[i];
                                    
                                    for (int j = i - kernelRadius + 1; j <= i + kernelRadius; j++) {
                                        // 计算权重
                                        float weight1 = kernel(float(j) - t, 3.0);  // 角度权重
                                        float weight2 = kernel(float(j) - t, 7.0);  // 半径权重
                                        
                                        // 处理循环索引
                                        int k = j;
                                        while (k < 0) k += controlPointsCount;
                                        k = k % controlPointsCount;
                                        
                                        // 获取角度并处理周期
                                        float angle = controlPointsAngles[k];
                                        float originalAngle = controlPointsOriginalAngles[k];
                                        
                                        while (originalAngle < reference - 3.141592653589793) {
                                            originalAngle += 6.283185307179586;
                                            angle += 6.283185307179586;
                                        }
                                        while (originalAngle > reference + 3.141592653589793) {
                                            originalAngle -= 6.283185307179586;
                                            angle -= 6.283185307179586;
                                        }
                                        
                                        // 累加加权值
                                        resultAngle += weight1 * angle;
                                        resultRadius += weight2 * controlPointsRadii[k];
                                        sum1 += weight1;
                                        sum2 += weight2;
                                    }
                                    
                                    // 计算平均值
                                    resultAngle /= sum1;
                                    resultRadius /= sum2;
                                    
                                    return vec2(resultAngle, resultRadius);
                                }
                                
                                void main() {
                                    vec4 color = texture2D(img, vUv);
                                    vec3 hsl = rgbToHsl(color.rgb);
                                    vec2 ar = getPointOnCurve(hsl.x);  // Angle and radius
                                    hsl.x = fract(ar.x / 6.283185307179586);
                                    if (ar.y <= 0.5)
                                        hsl.y *= ar.y * 2.;
                                    else
                                        hsl.y = pow(hsl.y, exp(-2. * (ar.y * 2. - 1.)));
                                    vec3 rgb = hslToRgb(hsl);
                                    gl_FragColor = vec4(rgb, color.a);
                                }
                            `
                        });
                        
                        // 创建平面显示图像
                        const geometry = new THREE.PlaneGeometry(2, 2);
                        const mesh = new THREE.Mesh(geometry, material);
                        scene.add(mesh);
                        
                        // 初始渲染
                        updateSize();
                        render();

                        const button = document.getElementById('save-button');
                        if (saveButtonOnClick)
                            button.removeEventListener('click', saveButtonOnClick);  // 移除之前的监听器
                        saveButtonOnClick = () => {
                            saveOriginalResImage(renderer, scene, camera, texture);
                        };
                        button.addEventListener('click', saveButtonOnClick);                
                    },
                    undefined,
                    function(err) {
                        console.error('Error loading image:', err);
                    }
                );
            };
            reader.readAsDataURL(file);
        }
    </script>
</body>
</html>
